{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CrSFML Tutorials Tutorials for CrSFML based on the official Tutorials for SFML . Read the tutorials Source on GitHub To contribute, edit the Markdown source files and make a pull request. Run mkdocs serve (requires pip install -r requirements.txt ) and open the link the browser to see the rendered result live. Contents System module Handling time Threads User data streams Window module Opening and managing an SFML window Events explained Keyboard, mouse and joysticks Using OpenGL in an SFML window Graphics module Drawing 2D stuff Sprites and textures Text and fonts Shapes Designing your own entities with vertex arrays Position, rotation, scale: transforming entities Adding special effects with shaders Controlling the 2D camera with views Audio module Playing sounds and music Recording audio Custom audio streams Spatialization: Sounds in 3D Network module Communication using sockets Using packets Web requests with HTTP File transfers with FTP","title":"Index"},{"location":"index.html#crsfml-tutorials","text":"","title":"CrSFML Tutorials"},{"location":"index.html#tutorials-for-crsfml-based-on-the-official-tutorials-for-sfml","text":"Read the tutorials Source on GitHub To contribute, edit the Markdown source files and make a pull request. Run mkdocs serve (requires pip install -r requirements.txt ) and open the link the browser to see the rendered result live.","title":"Tutorials for CrSFML based on the official Tutorials for SFML."},{"location":"index.html#contents","text":"System module Handling time Threads User data streams Window module Opening and managing an SFML window Events explained Keyboard, mouse and joysticks Using OpenGL in an SFML window Graphics module Drawing 2D stuff Sprites and textures Text and fonts Shapes Designing your own entities with vertex arrays Position, rotation, scale: transforming entities Adding special effects with shaders Controlling the 2D camera with views Audio module Playing sounds and music Recording audio Custom audio streams Spatialization: Sounds in 3D Network module Communication using sockets Using packets Web requests with HTTP File transfers with FTP","title":"Contents"},{"location":"audio/recording.html","text":"Recording audio Relevant example: sound_capture Recording to a sound buffer The most common use for captured audio data is for it to be saved to a sound buffer ( SoundBuffer ) so that it can either be played or saved to a file. This can be achieved with the very simple interface of the SoundBufferRecorder class: # first check if an input audio device is available on the system if ! SF :: SoundBufferRecorder . available? # error: audio capture is not available on this system ... end # create the recorder recorder = SF :: SoundBufferRecorder . new # start the capture recorder . start # wait... # stop the capture recorder . stop # retrieve the buffer that contains the captured audio data buffer = recorder . buffer The SoundBufferRecorder.available? class method checks if audio recording is supported by the system. It if returns false , you won't be able to use the SoundBufferRecorder class at all. The start and stop methods are self-explanatory. The capture runs in its own thread, which means that you can do whatever you want between start and stop. After the end of the capture, the recorded audio data is available in a sound buffer that you can get with the buffer method. With the recorded data, you can then: Save it to a file buffer . save_to_file ( \"my_record.ogg\" ) Play it directly sound = SF :: Sound . new ( buffer ) sound . play Access the raw audio data and analyze it, transform it, etc. samples = buffer . samples count = buffer . sample_count do_something ( samples , count ) If you want to use the captured audio data after the recorder is destroyed or restarted, don't forget to make a copy of the buffer. Selecting the input device If you have multiple sound input devices connected to your computer (for example a microphone, a sound interface (external soundcard) or a webcam microphone) you can specify the device that is used for recording. A sound input device is identified by its name. An Array(String) containing the names of all connected devices is available through the class method SoundBufferRecorder.available_devices . You can then select a device from the list for recording, by passing the chosen device name to the device= method. It is even possible to change the device on the fly (i.e. while recording). The name of the currently used device can be obtained by calling device . If you don't choose a device yourself, the default device will be used. Its name can be obtained through the default_device class method. Here is a small example of how to set the input device: # get the available sound input device names available_devices = SF :: SoundRecorder . available_devices # choose a device input_device = available_devices [ 0 ] # create the recorder recorder = SF :: SoundBufferRecorder . new # set the device unless recorder . device = input_device # error: device selection failed ... end # use recorder as usual","title":"Recording audio"},{"location":"audio/recording.html#recording-audio","text":"Relevant example: sound_capture","title":"Recording audio"},{"location":"audio/recording.html#recording-to-a-sound-buffer","text":"The most common use for captured audio data is for it to be saved to a sound buffer ( SoundBuffer ) so that it can either be played or saved to a file. This can be achieved with the very simple interface of the SoundBufferRecorder class: # first check if an input audio device is available on the system if ! SF :: SoundBufferRecorder . available? # error: audio capture is not available on this system ... end # create the recorder recorder = SF :: SoundBufferRecorder . new # start the capture recorder . start # wait... # stop the capture recorder . stop # retrieve the buffer that contains the captured audio data buffer = recorder . buffer The SoundBufferRecorder.available? class method checks if audio recording is supported by the system. It if returns false , you won't be able to use the SoundBufferRecorder class at all. The start and stop methods are self-explanatory. The capture runs in its own thread, which means that you can do whatever you want between start and stop. After the end of the capture, the recorded audio data is available in a sound buffer that you can get with the buffer method. With the recorded data, you can then: Save it to a file buffer . save_to_file ( \"my_record.ogg\" ) Play it directly sound = SF :: Sound . new ( buffer ) sound . play Access the raw audio data and analyze it, transform it, etc. samples = buffer . samples count = buffer . sample_count do_something ( samples , count ) If you want to use the captured audio data after the recorder is destroyed or restarted, don't forget to make a copy of the buffer.","title":"Recording to a sound buffer"},{"location":"audio/recording.html#selecting-the-input-device","text":"If you have multiple sound input devices connected to your computer (for example a microphone, a sound interface (external soundcard) or a webcam microphone) you can specify the device that is used for recording. A sound input device is identified by its name. An Array(String) containing the names of all connected devices is available through the class method SoundBufferRecorder.available_devices . You can then select a device from the list for recording, by passing the chosen device name to the device= method. It is even possible to change the device on the fly (i.e. while recording). The name of the currently used device can be obtained by calling device . If you don't choose a device yourself, the default device will be used. Its name can be obtained through the default_device class method. Here is a small example of how to set the input device: # get the available sound input device names available_devices = SF :: SoundRecorder . available_devices # choose a device input_device = available_devices [ 0 ] # create the recorder recorder = SF :: SoundBufferRecorder . new # set the device unless recorder . device = input_device # error: device selection failed ... end # use recorder as usual","title":"Selecting the input device"},{"location":"audio/sounds.html","text":"Playing sounds and music Sound or music? SFML provides two classes for playing audio: Sound and Music . They both provide more or less the same features, the main difference is how they work. Sound is a lightweight object that plays loaded audio data from a SoundBuffer . It should be used for small sounds that can fit in memory and should suffer no lag when they are played. Examples are gun shots, foot steps, etc. Music doesn't load all the audio data into memory, instead it streams it on the fly from the source file. It is typically used to play compressed music that lasts several minutes, and would otherwise take many seconds to load and eat hundreds of MB in memory. Loading and playing a sound As mentioned above, the sound data is not stored directly in Sound but in a separate class named SoundBuffer . This class encapsulates the audio data, which is basically an array of 16-bit signed integers (called \"audio samples\"). A sample is the amplitude of the sound signal at a given point in time, and an array of samples therefore represents a full sound. In fact, the Sound / SoundBuffer classes work the same way as Sprite / Texture from the graphics module. So if you understand how sprites and textures work together, you can apply the same concept to sounds and sound buffers. You can load a sound buffer from a file on disk with its from_file class method: SF :: SoundBuffer . from_file ( \"sound.wav\" ) As with everything else, you can also load an audio file from memory ( from_memory ) or from a custom input stream ( from_stream ). SFML supports the audio file formats WAV, OGG/Vorbis and FLAC. Due to licensing issues MP3 is not supported. You can also load a sound buffer directly from an array of samples, in the case they originate from another source: buffer . from_samples ( samples , samples . size , 2 , 44100 ) Since from_samples loads a raw array of samples rather than an audio file, it requires additional arguments in order to have a complete description of the sound. The first one (third argument) is the number of channels; 1 channel defines a mono sound, 2 channels define a stereo sound, etc. The second additional attribute (fourth argument) is the sample rate; it defines how many samples must be played per second in order to reconstruct the original sound. Now that the audio data is loaded, we can play it with a Sound instance. # load something into the sound buffer... buffer = ... sound = SF :: Sound . new ( buffer ) sound . play The cool thing is that you can assign the same sound buffer to multiple sounds if you want. You can even play them together without any issues. Sounds (and music) are played in a separate thread. This means that you are free to do whatever you want after calling play (except destroying the sound or its data, of course), the sound will continue to play until it's finished or explicitly stopped. Playing a music Unlike Sound , Music doesn't pre-load the audio data, instead it streams the data directly from the source. The initialization of music is thus more direct: music = SF :: Music . from_file ( \"music.ogg\" ) music . play It is important to note that, unlike all other SFML resources, the loading class method only opens the file. The music is not really loaded, this method merely opens it. The data is only loaded later, when the music is played. It also helps to keep in mind that the audio file has to remain available as long as it is played. The other loading methods of Music follow the same convention: from_memory , from_stream . What's next? Now that you are able to load and play a sound or music, let's see what you can do with it. To control playback, the following methods are available: play starts or resumes playback pause pauses playback stop stops playback and rewind playing_offset= changes the current playing position Example: # start playback sound . play # advance to 2 seconds sound . playing_offset = SF . seconds ( 2 ) # pause playback sound . pause # resume playback sound . play # stop playback and rewind sound . stop The status method returns the current status of a sound or music, you can use it to know whether it is stopped, playing or paused. Sound and music playback is also controlled by a few attributes which can be changed at any moment. The pitch is a factor that changes the perceived frequency of the sound: greater than 1 plays the sound at a higher pitch, less than 1 plays the sound at a lower pitch, and 1 leaves it unchanged. Changing the pitch has a side effect: it impacts the playing speed. sound . pitch = 1.2 The volume is... the volume. The value ranges from 0 (mute) to 100 (full volume). The default value is 100, which means that you can't make a sound louder than its initial volume. sound . volume = 50 The loop attribute controls whether the sound/music automatically loops or not. If it loops, it will restart playing from the beginning when it's finished, again and again until you explicitly call stop . If not set to loop, it will stop automatically when it's finished. sound . loop = true More attributes are available, but they are related to spatialization and are explained in the corresponding tutorial . Common mistakes Too many sounds One source of error is when you try to create a huge number of sounds. SFML internally has a limit; it can vary depending on the OS, but you should never exceed 256. This limit is the number of Sound and Music instances that can exist simultaneously. A good way to stay below the limit is to destroy (or recycle) unused sounds when they are no longer needed. This only applies if you have to manage a really large amount of sounds and music, of course. Destroying the music source while it plays Remember that a music needs its source as long as it is played. A music file on your disk probably won't be deleted or moved while your application plays it, however things get more complicated when you play a music from a file in memory, or from a custom input stream: # we start with a music file in memory (imagine that we extracted it from a zip archive) file_data = ... # we play it music = SF :: Music . from_memory ( file_data ) music . play # \"ok, it seems that we don't need the source file any longer\" file_data . clear # ERROR: the music was still streaming the contents of file_data! The behavior is now undefined","title":"Playing sounds and music"},{"location":"audio/sounds.html#playing-sounds-and-music","text":"","title":"Playing sounds and music"},{"location":"audio/sounds.html#sound-or-music","text":"SFML provides two classes for playing audio: Sound and Music . They both provide more or less the same features, the main difference is how they work. Sound is a lightweight object that plays loaded audio data from a SoundBuffer . It should be used for small sounds that can fit in memory and should suffer no lag when they are played. Examples are gun shots, foot steps, etc. Music doesn't load all the audio data into memory, instead it streams it on the fly from the source file. It is typically used to play compressed music that lasts several minutes, and would otherwise take many seconds to load and eat hundreds of MB in memory.","title":"Sound or music?"},{"location":"audio/sounds.html#loading-and-playing-a-sound","text":"As mentioned above, the sound data is not stored directly in Sound but in a separate class named SoundBuffer . This class encapsulates the audio data, which is basically an array of 16-bit signed integers (called \"audio samples\"). A sample is the amplitude of the sound signal at a given point in time, and an array of samples therefore represents a full sound. In fact, the Sound / SoundBuffer classes work the same way as Sprite / Texture from the graphics module. So if you understand how sprites and textures work together, you can apply the same concept to sounds and sound buffers. You can load a sound buffer from a file on disk with its from_file class method: SF :: SoundBuffer . from_file ( \"sound.wav\" ) As with everything else, you can also load an audio file from memory ( from_memory ) or from a custom input stream ( from_stream ). SFML supports the audio file formats WAV, OGG/Vorbis and FLAC. Due to licensing issues MP3 is not supported. You can also load a sound buffer directly from an array of samples, in the case they originate from another source: buffer . from_samples ( samples , samples . size , 2 , 44100 ) Since from_samples loads a raw array of samples rather than an audio file, it requires additional arguments in order to have a complete description of the sound. The first one (third argument) is the number of channels; 1 channel defines a mono sound, 2 channels define a stereo sound, etc. The second additional attribute (fourth argument) is the sample rate; it defines how many samples must be played per second in order to reconstruct the original sound. Now that the audio data is loaded, we can play it with a Sound instance. # load something into the sound buffer... buffer = ... sound = SF :: Sound . new ( buffer ) sound . play The cool thing is that you can assign the same sound buffer to multiple sounds if you want. You can even play them together without any issues. Sounds (and music) are played in a separate thread. This means that you are free to do whatever you want after calling play (except destroying the sound or its data, of course), the sound will continue to play until it's finished or explicitly stopped.","title":"Loading and playing a sound"},{"location":"audio/sounds.html#playing-a-music","text":"Unlike Sound , Music doesn't pre-load the audio data, instead it streams the data directly from the source. The initialization of music is thus more direct: music = SF :: Music . from_file ( \"music.ogg\" ) music . play It is important to note that, unlike all other SFML resources, the loading class method only opens the file. The music is not really loaded, this method merely opens it. The data is only loaded later, when the music is played. It also helps to keep in mind that the audio file has to remain available as long as it is played. The other loading methods of Music follow the same convention: from_memory , from_stream .","title":"Playing a music"},{"location":"audio/sounds.html#whats-next","text":"Now that you are able to load and play a sound or music, let's see what you can do with it. To control playback, the following methods are available: play starts or resumes playback pause pauses playback stop stops playback and rewind playing_offset= changes the current playing position Example: # start playback sound . play # advance to 2 seconds sound . playing_offset = SF . seconds ( 2 ) # pause playback sound . pause # resume playback sound . play # stop playback and rewind sound . stop The status method returns the current status of a sound or music, you can use it to know whether it is stopped, playing or paused. Sound and music playback is also controlled by a few attributes which can be changed at any moment. The pitch is a factor that changes the perceived frequency of the sound: greater than 1 plays the sound at a higher pitch, less than 1 plays the sound at a lower pitch, and 1 leaves it unchanged. Changing the pitch has a side effect: it impacts the playing speed. sound . pitch = 1.2 The volume is... the volume. The value ranges from 0 (mute) to 100 (full volume). The default value is 100, which means that you can't make a sound louder than its initial volume. sound . volume = 50 The loop attribute controls whether the sound/music automatically loops or not. If it loops, it will restart playing from the beginning when it's finished, again and again until you explicitly call stop . If not set to loop, it will stop automatically when it's finished. sound . loop = true More attributes are available, but they are related to spatialization and are explained in the corresponding tutorial .","title":"What's next?"},{"location":"audio/sounds.html#common-mistakes","text":"","title":"Common mistakes"},{"location":"audio/sounds.html#too-many-sounds","text":"One source of error is when you try to create a huge number of sounds. SFML internally has a limit; it can vary depending on the OS, but you should never exceed 256. This limit is the number of Sound and Music instances that can exist simultaneously. A good way to stay below the limit is to destroy (or recycle) unused sounds when they are no longer needed. This only applies if you have to manage a really large amount of sounds and music, of course.","title":"Too many sounds"},{"location":"audio/sounds.html#destroying-the-music-source-while-it-plays","text":"Remember that a music needs its source as long as it is played. A music file on your disk probably won't be deleted or moved while your application plays it, however things get more complicated when you play a music from a file in memory, or from a custom input stream: # we start with a music file in memory (imagine that we extracted it from a zip archive) file_data = ... # we play it music = SF :: Music . from_memory ( file_data ) music . play # \"ok, it seems that we don't need the source file any longer\" file_data . clear # ERROR: the music was still streaming the contents of file_data! The behavior is now undefined","title":"Destroying the music source while it plays"},{"location":"audio/spatialization.html","text":"Spatialization: Sounds in 3D Introduction By default, sounds and music are played at full volume in each speaker; they are not spatialized . If a sound is emitted by an entity which is to the right of the screen, you would probably want to hear it from the right speaker. If a music is being played behind the player, you would want to hear it from the rear speakers of your Dolby 5.1 sound system. How can this be achieved? Spatialized sounds are mono A sound can be spatialized only if it has a single channel, i.e. if it's a mono sound. Spatialization is disabled for sounds with more channels, since they already explicitly decide how to use the speakers. This is very important to keep in mind. The listener All the sounds and music in your audio environment will be heard by a single actor: the listener . What is output from your speakers is determined by what the listener hears. The class which defines the listener's properties is Listener . Since the listener is unique in the environment, this class only contains class methods and is not meant to be instantiated. First, you can set the listener's position in the scene: SF :: Listener . position = SF . vector3f ( 10.0 , 0.0 , 5.0 ) If you have a 2D world you can just use the same Y value everywhere, usually 0. In addition to its position, you can define the listener's orientation: SF :: Listener . direction = SF . vector3f ( 1.0 , 0.0 , 0.0 ) Here, the listener is oriented along the +X axis. This means that, for example, a sound emitted at (15, 0, 5) will be heard from the right speaker. The \"up\" vector of the listener is set to (0, 1, 0) by default, in other words, the top of the listener's head is pointing towards +Y. You can change the \"up\" vector if you want. It is rarely necessary though. SF :: Listener . up_vector = SF . vector3f ( 1.0 , 1.0 , 0.0 ) This corresponds to the listener tilting their head towards the right (+X). Finally, the listener can adjust the global volume of the scene: SF :: Listener . global_volume = 50.0 The value of the volume is in the range [0 .. 100], so setting it to 50 reduces it to half of the original volume. Of course, all these properties can be read with the corresponding getter methods. Audio sources Every audio source provided by SFML (sounds, music, streams) defines the same properties for spatialization. The main property is the position of the audio source. sound . position = SF . vector3f ( 2.0 , 0.0 , - 5.0 ) This position is absolute by default, but it can be relative to the listener if needed. sound . relative_to_listener = true This can be useful for sounds emitted by the listener itself (like a gun shot, or foot steps). It also has the interesting side-effect of disabling spatialization if you set the position of the audio source to (0, 0, 0). Non-spatialized sounds can be required in various situations: GUI sounds (clicks), ambient music, etc. You can also set the factor by which audio sources will be attenuated depending on their distance to the listener. sound . min_distance = 5.0 sound . attenuation = 10.0 The minimum distance is the distance under which the sound will be heard at its maximum volume. As an example, louder sounds such as explosions should have a higher minimum distance to ensure that they will be heard from far away. Please note that a minimum distance of 0 (the sound is inside the head of the listener!) would lead to an incorrect spatialization and result in a non-attenuated sound. 0 is an invalid value, never use it. The attenuation is a multiplicative factor. The greater the attenuation, the less it will be heard when the sound moves away from the listener. To get a non-attenuated sound, you can use 0. On the other hand, using a value like 100 will highly attenuate the sound, which means that it will be heard only if very close to the listener. Here is the exact attenuation formula, in case you need accurate values: MinDistance is the sound's minimum distance, set with min_distance= Attenuation is the sound's attenuation, set with attenuation= Distance is the distance between the sound and the listener Volume factor is the calculated factor, in range [0 .. 1], that will be applied to the sound's volume Volume factor = MinDistance / (MinDistance + Attenuation * (max(Distance, MinDistance) - MinDistance))","title":"Spatialization: Sounds in 3D"},{"location":"audio/spatialization.html#spatialization-sounds-in-3d","text":"","title":"Spatialization: Sounds in 3D"},{"location":"audio/spatialization.html#introduction","text":"By default, sounds and music are played at full volume in each speaker; they are not spatialized . If a sound is emitted by an entity which is to the right of the screen, you would probably want to hear it from the right speaker. If a music is being played behind the player, you would want to hear it from the rear speakers of your Dolby 5.1 sound system. How can this be achieved?","title":"Introduction"},{"location":"audio/spatialization.html#spatialized-sounds-are-mono","text":"A sound can be spatialized only if it has a single channel, i.e. if it's a mono sound. Spatialization is disabled for sounds with more channels, since they already explicitly decide how to use the speakers. This is very important to keep in mind.","title":"Spatialized sounds are mono"},{"location":"audio/spatialization.html#the-listener","text":"All the sounds and music in your audio environment will be heard by a single actor: the listener . What is output from your speakers is determined by what the listener hears. The class which defines the listener's properties is Listener . Since the listener is unique in the environment, this class only contains class methods and is not meant to be instantiated. First, you can set the listener's position in the scene: SF :: Listener . position = SF . vector3f ( 10.0 , 0.0 , 5.0 ) If you have a 2D world you can just use the same Y value everywhere, usually 0. In addition to its position, you can define the listener's orientation: SF :: Listener . direction = SF . vector3f ( 1.0 , 0.0 , 0.0 ) Here, the listener is oriented along the +X axis. This means that, for example, a sound emitted at (15, 0, 5) will be heard from the right speaker. The \"up\" vector of the listener is set to (0, 1, 0) by default, in other words, the top of the listener's head is pointing towards +Y. You can change the \"up\" vector if you want. It is rarely necessary though. SF :: Listener . up_vector = SF . vector3f ( 1.0 , 1.0 , 0.0 ) This corresponds to the listener tilting their head towards the right (+X). Finally, the listener can adjust the global volume of the scene: SF :: Listener . global_volume = 50.0 The value of the volume is in the range [0 .. 100], so setting it to 50 reduces it to half of the original volume. Of course, all these properties can be read with the corresponding getter methods.","title":"The listener"},{"location":"audio/spatialization.html#audio-sources","text":"Every audio source provided by SFML (sounds, music, streams) defines the same properties for spatialization. The main property is the position of the audio source. sound . position = SF . vector3f ( 2.0 , 0.0 , - 5.0 ) This position is absolute by default, but it can be relative to the listener if needed. sound . relative_to_listener = true This can be useful for sounds emitted by the listener itself (like a gun shot, or foot steps). It also has the interesting side-effect of disabling spatialization if you set the position of the audio source to (0, 0, 0). Non-spatialized sounds can be required in various situations: GUI sounds (clicks), ambient music, etc. You can also set the factor by which audio sources will be attenuated depending on their distance to the listener. sound . min_distance = 5.0 sound . attenuation = 10.0 The minimum distance is the distance under which the sound will be heard at its maximum volume. As an example, louder sounds such as explosions should have a higher minimum distance to ensure that they will be heard from far away. Please note that a minimum distance of 0 (the sound is inside the head of the listener!) would lead to an incorrect spatialization and result in a non-attenuated sound. 0 is an invalid value, never use it. The attenuation is a multiplicative factor. The greater the attenuation, the less it will be heard when the sound moves away from the listener. To get a non-attenuated sound, you can use 0. On the other hand, using a value like 100 will highly attenuate the sound, which means that it will be heard only if very close to the listener. Here is the exact attenuation formula, in case you need accurate values: MinDistance is the sound's minimum distance, set with min_distance= Attenuation is the sound's attenuation, set with attenuation= Distance is the distance between the sound and the listener Volume factor is the calculated factor, in range [0 .. 1], that will be applied to the sound's volume Volume factor = MinDistance / (MinDistance + Attenuation * (max(Distance, MinDistance) - MinDistance))","title":"Audio sources"},{"location":"audio/streams.html","text":"Custom audio streams Relevant example: echo Audio stream? What's that? An audio stream is similar to music (remember the Music class?). It has almost the same methods and behaves the same. The only difference is that an audio stream doesn't play an audio file: Instead, it plays a custom audio source that you directly provide. In other words, defining your own audio stream allows you to play from more than just a file: A sound streamed over the network, music generated by your program, an audio format that SFML doesn't support, etc. In fact, the Music class is just a specialized audio stream that gets its audio samples from a file. Since we're talking about streaming , we'll deal with audio data that cannot be loaded entirely in memory, and will instead be loaded in small chunks while it is being played. If your sound can be loaded completely and can fit in memory, then audio streams won't help you: Just load the audio data into a SoundBuffer and use a regular Sound to play it. SF::SoundStream In order to define your own audio stream, you need to inherit from the SoundStream abstract base class. There are two methods to override in your derived class: on_get_data and on_seek . class MyAudioStream < SF :: SoundStream def on_get_data () : Slice ( Int16 )? end def on_seek ( time_offset : Time ) end end on_get_data is called by the base class whenever it runs out of audio samples and needs more of them. You must provide new audio samples by returning a slice with data: class MyAudioStream < SF :: SoundStream def get_data () samples_array . to_slice end end You must return a non-empty slice when everything is all right, or nil if playback must be stopped, either because an error has occurred or because there's simply no more audio data to play. SFML makes an internal copy of the audio samples as soon as on_get_data returns, so you don't have to keep the original data alive if you don't want to. The on_seek method is called when the playing_offset= public method is called. Its purpose is to change the current playing position in the source data. The parameter is a time value representing the new position, from the beginning of the sound ( not from the current position). This method is sometimes impossible to implement. In those cases leave it empty, and tell the users of your class that changing the playing position is not supported. Now your class is almost ready to work. The only thing that SoundStream needs to know now is the channel count and sample rate of your stream, so that it can be played as expected. # where this is done totally depends on how your stream class is designed MyAudioStream . new ( channel_count : ... , sample_rate : ... ) Threading issues Audio streams are always played in a separate thread, therefore it is important to know what happens exactly, and where. on_seek is called directly by the playing_offset= function, so it is always executed in the caller thread. However, the on_get_data function will be called repeatedly as long as the stream is being played, in a separate thread created by SFML. If your stream uses data that may be accessed concurrently in both the caller thread and in the playing thread, you have to protect it (with a mutex for example) in order to avoid concurrent access, which may cause undefined behavior -- corrupt data being played, crashes, etc. If you're not familiar enough with threading, you can refer to the corresponding tutorial for more information. Using your audio stream Now that you have defined your own audio stream class, let's see how to use it. In fact, things are very similar to what's shown in the tutorial about SF::Music . You can control playback with the play , pause , stop and playing_offset= methods. You can also play with the sound's properties, such as the volume or the pitch. You can refer to the API documentation or to the other audio tutorials for more details. A simple example Here is a very simple example of a custom audio stream class which plays the data of a sound buffer. Such a class might seem totally useless, but the point here is to focus on how the data is streamed by the class, regardless of where it comes from. require \"crsfml/system\" require \"crsfml/audio\" # custom audio stream that plays a loaded buffer class MyStream < SF :: SoundStream @samples : Slice ( Int16 ) def initialize ( @buffer : SF :: SoundBuffer ) # get a slice that points to the buffer with samples @samples = buffer . samples . to_slice ( buffer . sample_count ) # reset the current playing position @current_sample = 0 # initialize the base class super ( buffer . channel_count , buffer . sample_rate ) end def on_get_data () # number of samples to stream every time the function is called; # in a more robust implementation, it should be a fixed # amount of time rather than an arbitrary number of samples to_stream = { 50000 , @samples . size - @current_sample } . min # if the end is close, set the number to play the remaining samples # if nothing left to play return nil unless to_stream > 0 # the next audio samples to be played result = ( @samples . to_unsafe + @current_sample ) . to_slice ( to_stream ) # advance the position @current_sample += to_stream result end def on_seek ( time_offset ) # compute the corresponding sample index according to the # sample rate and channel count @current_sample = ( time_offset . as_seconds * sample_rate * channel_count ) . to_i end end # load an audio buffer from a sound file buffer = SF :: SoundBuffer . from_file ( \"canary.wav\" ) # initialize and play our custom stream stream = MyStream . new ( buffer ) stream . play # let it play until it is finished while stream . status == SF :: SoundSource :: Playing SF . sleep ( SF . seconds ( 1 )) # jump back every so often stream . playing_offset -= SF . seconds ( 0.7 ) end","title":"Custom audio streams"},{"location":"audio/streams.html#custom-audio-streams","text":"Relevant example: echo","title":"Custom audio streams"},{"location":"audio/streams.html#audio-stream-whats-that","text":"An audio stream is similar to music (remember the Music class?). It has almost the same methods and behaves the same. The only difference is that an audio stream doesn't play an audio file: Instead, it plays a custom audio source that you directly provide. In other words, defining your own audio stream allows you to play from more than just a file: A sound streamed over the network, music generated by your program, an audio format that SFML doesn't support, etc. In fact, the Music class is just a specialized audio stream that gets its audio samples from a file. Since we're talking about streaming , we'll deal with audio data that cannot be loaded entirely in memory, and will instead be loaded in small chunks while it is being played. If your sound can be loaded completely and can fit in memory, then audio streams won't help you: Just load the audio data into a SoundBuffer and use a regular Sound to play it.","title":"Audio stream? What's that?"},{"location":"audio/streams.html#sfsoundstream","text":"In order to define your own audio stream, you need to inherit from the SoundStream abstract base class. There are two methods to override in your derived class: on_get_data and on_seek . class MyAudioStream < SF :: SoundStream def on_get_data () : Slice ( Int16 )? end def on_seek ( time_offset : Time ) end end on_get_data is called by the base class whenever it runs out of audio samples and needs more of them. You must provide new audio samples by returning a slice with data: class MyAudioStream < SF :: SoundStream def get_data () samples_array . to_slice end end You must return a non-empty slice when everything is all right, or nil if playback must be stopped, either because an error has occurred or because there's simply no more audio data to play. SFML makes an internal copy of the audio samples as soon as on_get_data returns, so you don't have to keep the original data alive if you don't want to. The on_seek method is called when the playing_offset= public method is called. Its purpose is to change the current playing position in the source data. The parameter is a time value representing the new position, from the beginning of the sound ( not from the current position). This method is sometimes impossible to implement. In those cases leave it empty, and tell the users of your class that changing the playing position is not supported. Now your class is almost ready to work. The only thing that SoundStream needs to know now is the channel count and sample rate of your stream, so that it can be played as expected. # where this is done totally depends on how your stream class is designed MyAudioStream . new ( channel_count : ... , sample_rate : ... )","title":"SF::SoundStream"},{"location":"audio/streams.html#threading-issues","text":"Audio streams are always played in a separate thread, therefore it is important to know what happens exactly, and where. on_seek is called directly by the playing_offset= function, so it is always executed in the caller thread. However, the on_get_data function will be called repeatedly as long as the stream is being played, in a separate thread created by SFML. If your stream uses data that may be accessed concurrently in both the caller thread and in the playing thread, you have to protect it (with a mutex for example) in order to avoid concurrent access, which may cause undefined behavior -- corrupt data being played, crashes, etc. If you're not familiar enough with threading, you can refer to the corresponding tutorial for more information.","title":"Threading issues"},{"location":"audio/streams.html#using-your-audio-stream","text":"Now that you have defined your own audio stream class, let's see how to use it. In fact, things are very similar to what's shown in the tutorial about SF::Music . You can control playback with the play , pause , stop and playing_offset= methods. You can also play with the sound's properties, such as the volume or the pitch. You can refer to the API documentation or to the other audio tutorials for more details.","title":"Using your audio stream"},{"location":"audio/streams.html#a-simple-example","text":"Here is a very simple example of a custom audio stream class which plays the data of a sound buffer. Such a class might seem totally useless, but the point here is to focus on how the data is streamed by the class, regardless of where it comes from. require \"crsfml/system\" require \"crsfml/audio\" # custom audio stream that plays a loaded buffer class MyStream < SF :: SoundStream @samples : Slice ( Int16 ) def initialize ( @buffer : SF :: SoundBuffer ) # get a slice that points to the buffer with samples @samples = buffer . samples . to_slice ( buffer . sample_count ) # reset the current playing position @current_sample = 0 # initialize the base class super ( buffer . channel_count , buffer . sample_rate ) end def on_get_data () # number of samples to stream every time the function is called; # in a more robust implementation, it should be a fixed # amount of time rather than an arbitrary number of samples to_stream = { 50000 , @samples . size - @current_sample } . min # if the end is close, set the number to play the remaining samples # if nothing left to play return nil unless to_stream > 0 # the next audio samples to be played result = ( @samples . to_unsafe + @current_sample ) . to_slice ( to_stream ) # advance the position @current_sample += to_stream result end def on_seek ( time_offset ) # compute the corresponding sample index according to the # sample rate and channel count @current_sample = ( time_offset . as_seconds * sample_rate * channel_count ) . to_i end end # load an audio buffer from a sound file buffer = SF :: SoundBuffer . from_file ( \"canary.wav\" ) # initialize and play our custom stream stream = MyStream . new ( buffer ) stream . play # let it play until it is finished while stream . status == SF :: SoundSource :: Playing SF . sleep ( SF . seconds ( 1 )) # jump back every so often stream . playing_offset -= SF . seconds ( 0.7 ) end","title":"A simple example"},{"location":"graphics/draw.html","text":"Drawing 2D stuff Introduction As you learnt in the previous tutorials, CrSFML's window module provides an easy way to open an OpenGL window and handle its events, but it doesn't help when it comes to drawing something. The only option which is left to you is to use the powerful, yet complex and low level OpenGL API. Fortunately, CrSFML provides a graphics module which will help you draw 2D entities in a much simpler way than with OpenGL. The drawing window To draw the entities provided by the graphics module, you must use a specialized window class: RenderWindow . This class is derived from Window , and inherits all its methods. Everything that you've learnt about Window (creation, event handling, controlling the framerate, mixing with OpenGL, etc.) is applicable to RenderWindow as well. On top of that, RenderWindow adds high-level methods to help you draw things easily. In this tutorial we'll focus on two of these methods: clear and draw . They are as simple as their name implies: clear clears the whole window with the chosen color, and draw draws whatever object you pass to it. Here is what a typical main loop looks like with a render window: require \"crsfml\" # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) # run the program as long as the window is open while window . open? # check all the window's events that were triggered since the last iteration of the loop while event = window . poll_event # \"close requested\" event: we close the window if event . is_a? SF :: Event :: Closed window . close end end # clear the window with black color window . clear ( SF :: Color :: Black ) # draw everything here... window . draw ( ... ) # end the current frame window . display end Calling clear before drawing anything is mandatory, otherwise the contents from previous frames will be present behind anything you draw. The only exception is when you cover the entire window with what you draw, so that no pixel is not drawn to. In this case you can avoid calling clear (although it won't have a noticeable impact on performance). Calling display is also mandatory, it takes what was drawn since the last call to display and displays it on the window. Indeed, things are not drawn directly to the window, but to a hidden buffer. This buffer is then copied to the window when you call display \u2013 this is called double-buffering . This clear/draw/display cycle is the only good way to draw things. Don't try other strategies, such as keeping pixels from the previous frame, \"erasing\" pixels, or drawing once and calling display multiple times. You'll get strange results due to double-buffering. Modern graphics hardware and APIs are really made for repeated clear/draw/display cycles where everything is completely refreshed at each iteration of the main loop. Don't be scared to draw 1000 sprites 60 times per second, you're far below the millions of triangles that your computer can handle. What can I draw now? Now that you have a main loop which is ready to draw, let's see what, and how, you can actually draw there. SFML provides four kinds of drawable entities: three of them are ready to be used ( sprites , text and shapes ), the last one is the building block that will help you create your own drawable entities ( vertex arrays ). Although they share some common properties, each of these entities come with their own nuances and are therefore explained in dedicated tutorials: Sprite tutorial Text tutorial Shape tutorial Vertex array tutorial Off-screen drawing SFML also provides a way to draw to a texture instead of directly to a window. To do so, use a RenderTexture instead of a RenderWindow . It has the same methods for drawing, inherited from their common base: RenderTarget . # create a 500x500 render-texture render_texture = SF :: RenderTexture . new ( 500 , 500 ) # drawing uses the same methods render_texture . clear ( SF :: Color :: Blue ) render_texture . draw ( sprite ) # or any other drawable render_texture . display # get the target texture (where the stuff has been drawn) texture = render_texture . texture # draw it to the window sprite = SF :: Sprite . new ( texture ) window . draw ( sprite ) The texture method returns a read-only texture, which means that you can only use it, not modify it. If you need to modify it before using it, you can copy it to your own Texture instance and modify that instead. RenderTexture also has the same methods as RenderWindow for handling views and OpenGL (see the corresponding tutorials for more details). If you use OpenGL to draw to the render-texture, you can request creation of a depth buffer by using the third optional argument of the constructor. SF :: RenderTexture . new ( 500 , 500 , true ) # enable depth buffer Drawing from threads CrSFML supports multi-threaded drawing, and you don't even have to do anything to make it work. The only thing to remember is to deactivate a window before using it in another thread. That's because a window (more precisely its OpenGL context) cannot be active in more than one thread at the same time. def render_thread ( window ) # the rendering loop while window . open? # draw... # end the current frame window . display end end # create the window (remember: it's safer to create it in the main thread due to OS limitations) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" ) # deactivate its OpenGL context window . active = false # launch the rendering thread thread = SF :: Thread . new ( -> { render_thread ( window ) }) thread . launch # the event/logic/whatever loop while window . open? ... end As you can see, you don't even need to bother with the activation of the window in the rendering thread, CrSFML does it automatically for you whenever it needs to be done. Remember to always create the window and handle its events in the main thread for maximum portability. This is explained in the window tutorial .","title":"Drawing 2D stuff"},{"location":"graphics/draw.html#drawing-2d-stuff","text":"","title":"Drawing 2D stuff"},{"location":"graphics/draw.html#introduction","text":"As you learnt in the previous tutorials, CrSFML's window module provides an easy way to open an OpenGL window and handle its events, but it doesn't help when it comes to drawing something. The only option which is left to you is to use the powerful, yet complex and low level OpenGL API. Fortunately, CrSFML provides a graphics module which will help you draw 2D entities in a much simpler way than with OpenGL.","title":"Introduction"},{"location":"graphics/draw.html#the-drawing-window","text":"To draw the entities provided by the graphics module, you must use a specialized window class: RenderWindow . This class is derived from Window , and inherits all its methods. Everything that you've learnt about Window (creation, event handling, controlling the framerate, mixing with OpenGL, etc.) is applicable to RenderWindow as well. On top of that, RenderWindow adds high-level methods to help you draw things easily. In this tutorial we'll focus on two of these methods: clear and draw . They are as simple as their name implies: clear clears the whole window with the chosen color, and draw draws whatever object you pass to it. Here is what a typical main loop looks like with a render window: require \"crsfml\" # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) # run the program as long as the window is open while window . open? # check all the window's events that were triggered since the last iteration of the loop while event = window . poll_event # \"close requested\" event: we close the window if event . is_a? SF :: Event :: Closed window . close end end # clear the window with black color window . clear ( SF :: Color :: Black ) # draw everything here... window . draw ( ... ) # end the current frame window . display end Calling clear before drawing anything is mandatory, otherwise the contents from previous frames will be present behind anything you draw. The only exception is when you cover the entire window with what you draw, so that no pixel is not drawn to. In this case you can avoid calling clear (although it won't have a noticeable impact on performance). Calling display is also mandatory, it takes what was drawn since the last call to display and displays it on the window. Indeed, things are not drawn directly to the window, but to a hidden buffer. This buffer is then copied to the window when you call display \u2013 this is called double-buffering . This clear/draw/display cycle is the only good way to draw things. Don't try other strategies, such as keeping pixels from the previous frame, \"erasing\" pixels, or drawing once and calling display multiple times. You'll get strange results due to double-buffering. Modern graphics hardware and APIs are really made for repeated clear/draw/display cycles where everything is completely refreshed at each iteration of the main loop. Don't be scared to draw 1000 sprites 60 times per second, you're far below the millions of triangles that your computer can handle.","title":"The drawing window"},{"location":"graphics/draw.html#what-can-i-draw-now","text":"Now that you have a main loop which is ready to draw, let's see what, and how, you can actually draw there. SFML provides four kinds of drawable entities: three of them are ready to be used ( sprites , text and shapes ), the last one is the building block that will help you create your own drawable entities ( vertex arrays ). Although they share some common properties, each of these entities come with their own nuances and are therefore explained in dedicated tutorials: Sprite tutorial Text tutorial Shape tutorial Vertex array tutorial","title":"What can I draw now?"},{"location":"graphics/draw.html#off-screen-drawing","text":"SFML also provides a way to draw to a texture instead of directly to a window. To do so, use a RenderTexture instead of a RenderWindow . It has the same methods for drawing, inherited from their common base: RenderTarget . # create a 500x500 render-texture render_texture = SF :: RenderTexture . new ( 500 , 500 ) # drawing uses the same methods render_texture . clear ( SF :: Color :: Blue ) render_texture . draw ( sprite ) # or any other drawable render_texture . display # get the target texture (where the stuff has been drawn) texture = render_texture . texture # draw it to the window sprite = SF :: Sprite . new ( texture ) window . draw ( sprite ) The texture method returns a read-only texture, which means that you can only use it, not modify it. If you need to modify it before using it, you can copy it to your own Texture instance and modify that instead. RenderTexture also has the same methods as RenderWindow for handling views and OpenGL (see the corresponding tutorials for more details). If you use OpenGL to draw to the render-texture, you can request creation of a depth buffer by using the third optional argument of the constructor. SF :: RenderTexture . new ( 500 , 500 , true ) # enable depth buffer","title":"Off-screen drawing"},{"location":"graphics/draw.html#drawing-from-threads","text":"CrSFML supports multi-threaded drawing, and you don't even have to do anything to make it work. The only thing to remember is to deactivate a window before using it in another thread. That's because a window (more precisely its OpenGL context) cannot be active in more than one thread at the same time. def render_thread ( window ) # the rendering loop while window . open? # draw... # end the current frame window . display end end # create the window (remember: it's safer to create it in the main thread due to OS limitations) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" ) # deactivate its OpenGL context window . active = false # launch the rendering thread thread = SF :: Thread . new ( -> { render_thread ( window ) }) thread . launch # the event/logic/whatever loop while window . open? ... end As you can see, you don't even need to bother with the activation of the window in the rendering thread, CrSFML does it automatically for you whenever it needs to be done. Remember to always create the window and handle its events in the main thread for maximum portability. This is explained in the window tutorial .","title":"Drawing from threads"},{"location":"graphics/shader.html","text":"Adding special effects with shaders Relevant example: shader Introduction A shader is a small program that is executed on the graphics card. It provides the programmer with more control over the drawing process and in a more flexible and simple way than using the fixed set of states and operations provided by OpenGL. With this additional flexibility, shaders are used to create effects that would be too complicated, if not impossible, to describe with regular OpenGL functions: Per-pixel lighting, shadows, etc. Today's graphics cards and newer versions of OpenGL are already entirely shader-based, and the fixed set of states and functions (which is called the \"fixed pipeline\") that you might know of has been deprecated and will likely be removed in the future. Shaders are written in GLSL ( OpenGL Shading Language ), which is very similar to the C programming language. There are two types of shaders: vertex shaders and fragment (or pixel) shaders. Vertex shaders are run for each vertex, while fragment shaders are run for every generated fragment (pixel). Depending on what kind of effect you want to achieve, you can provide a vertex shader, a fragment shader, or both. To understand what shaders do and how to use them efficiently, it is important to understand the basics of the rendering pipeline. You must also learn how to write GLSL programs and find good tutorials and examples to get started. You can also have a look at the \"Shader\" example that comes with the SFML SDK. This tutorial will only focus on the CrSFML specific part: Loading and applying your shaders -- not writing them. Loading shaders In CrSFML, shaders are represented by the Shader class. It handles both the vertex and fragment shaders: A Shader object is a combination of both (or only one, if the other is not provided). Even though shaders have become commonplace, there are still old graphics cards that might not support them. The first thing you should do in your program is check if shaders are available on the system: if ! SF :: Shader . available? # shaders are not available... end Any attempt to use the Shader class will fail if SF::Shader.available? returns false . The most common way of loading a shader is from a file on disk, which is done with the from_file class method. # load only the vertex shader shader = SF :: Shader . from_file ( \"vertex_shader.vert\" , SF :: Shader :: Vertex ) # load only the fragment shader shader = SF :: Shader . from_file ( \"fragment_shader.frag\" , SF :: Shader :: Fragment ) # load both shaders shader = SF :: Shader . from_file ( \"vertex_shader.vert\" , \"fragment_shader.frag\" ) Shader source is contained in simple text files (like your Crystal code). Their extension doesn't really matter, it can be anything you want, you can even omit it. \".vert\" and \".frag\" are just examples of possible extensions. The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is: When you run the application from your desktop environment, the working directory is the executable folder. Shaders can also be loaded directly from strings, with the from_memory class method. This can be useful if you want to embed the shader source directly into your program. vertex_shader = \" void main() { ... } \" fragment_shader = \" void main() { ... } \" # load only the vertex shader shader = SF :: Shader . from_memory ( vertex_shader , SF :: Shader :: Vertex ) # load only the fragment shader shader = SF :: Shader . from_memory ( fragment_shader , SF :: Shader :: Fragment ) # load both shaders shader = SF :: Shader . from_memory ( vertex_shader , fragment_shader ) And finally, like all other SFML resources, shaders can also be loaded from a custom input stream with the from_stream class method. If loading fails, don't forget to check the standard error output (the console) to see a detailed report from the GLSL compiler. Using a shader Using a shader is simple, just pass it as an additional argument to the draw method. window . draw ( whatever , SF :: RenderStates . new ( shader : shader )) Passing variables to a shader Like any other program, a shader can take parameters so that it is able to behave differently from one draw to another. These parameters are declared as global variables known as uniforms in the shader. uniform float myvar ; void main () { // use myvar... } Uniforms can be set by the Crystal program, using the various overloads of the set_parameter method in the Shader class. shader . set_parameter ( \"my_var\" , 5.0 ) # shorthand: shader . my_var 5.0 set_parameter 's overloads support all the types provided by CrSFML: Float (GLSL type float ) 2 Float s or SF::Vector2f (GLSL type vec2 ) 3 Float s or SF::Vector3f (GLSL type vec3 ) 4 Float s (GLSL type vec4 ) SF::Color (GLSL type vec4 ) SF::Transform (GLSL type mat4 ) SF::Texture (GLSL type sampler2D ) The GLSL compiler optimizes out unused variables (here, \"unused\" means \"not involved in the calculation of the final vertex/pixel\"). So don't be surprised if you get error messages such as Failed to find variable \"xxx\" in shader when you call set_parameter during your tests. Minimal shaders You won't learn how to write GLSL shaders here, but it is essential that you know what input SFML provides to the shaders and what it expects you to do with it. Vertex shader SFML has a fixed vertex format which is described by the Vertex structure. A SFML vertex contains a 2D position, a color, and 2D texture coordinates. This is the exact input that you will get in the vertex shader, stored in the built-in gl_Vertex , gl_Color and gl_MultiTexCoord0 variables (you don't need to declare them). void main () { // transform the vertex position gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex ; // transform the texture coordinates gl_TexCoord [ 0 ] = gl_TextureMatrix [ 0 ] * gl_MultiTexCoord0 ; // forward the vertex color gl_FrontColor = gl_Color ; } The position usually needs to be transformed by the model-view and projection matrices, which contain the entity transform combined with the current view. The texture coordinates need to be transformed by the texture matrix (this matrix likely doesn't mean anything to you, it is just an SFML implementation detail). And finally, the color just needs to be forwarded. Of course, you can ignore the texture coordinates and/or the color if you don't make use of them. All these variables will then be interpolated over the primitive by the graphics card, and passed to the fragment shader. Fragment shader The fragment shader functions quite similarly: It receives the texture coordinates and the color of a generated fragment. There's no position any more, at this point the graphics card has already computed the final raster position of the fragment. However if you deal with textured entities, you'll also need the current texture. uniform sampler2D texture ; void main () { // lookup the pixel in the texture vec4 pixel = texture2D ( texture , gl_TexCoord [ 0 ]. xy ); // multiply it by the color gl_FragColor = gl_Color * pixel ; } The current texture is not automatic, you need to treat it like you do the other input variables, and explicitly set it from your C++ program. Since each entity can have a different texture, and worse, there might be no way for you to get it and pass it to the shader, SFML provides a special overload of the set_parameter method that does this job for you. shader.set_parameter \"texture\", SF::Shader::CurrentTexture This special parameter automatically sets the texture of the entity being drawn to the shader variable with the given name. Every time you draw a new entity, SFML will update the shader texture variable accordingly. If you want to see nice examples of shaders in action, you can have a look at the Shader example in the SFML SDK. Using a SF::Shader with OpenGL code If you're using OpenGL rather than the graphics entities of SFML, you can still use Shader as a wrapper around an OpenGL program object and use it within your OpenGL code. To activate a Shader for drawing (the equivalent of glUseProgram ), you have to call the bind class method: shader = SF :: Shader . new ... # bind the shader SF :: Shader . bind ( shader ) # draw your OpenGL entity here... # bind no shader SF :: Shader . bind ( nil )","title":"Adding special effects with shaders"},{"location":"graphics/shader.html#adding-special-effects-with-shaders","text":"Relevant example: shader","title":"Adding special effects with shaders"},{"location":"graphics/shader.html#introduction","text":"A shader is a small program that is executed on the graphics card. It provides the programmer with more control over the drawing process and in a more flexible and simple way than using the fixed set of states and operations provided by OpenGL. With this additional flexibility, shaders are used to create effects that would be too complicated, if not impossible, to describe with regular OpenGL functions: Per-pixel lighting, shadows, etc. Today's graphics cards and newer versions of OpenGL are already entirely shader-based, and the fixed set of states and functions (which is called the \"fixed pipeline\") that you might know of has been deprecated and will likely be removed in the future. Shaders are written in GLSL ( OpenGL Shading Language ), which is very similar to the C programming language. There are two types of shaders: vertex shaders and fragment (or pixel) shaders. Vertex shaders are run for each vertex, while fragment shaders are run for every generated fragment (pixel). Depending on what kind of effect you want to achieve, you can provide a vertex shader, a fragment shader, or both. To understand what shaders do and how to use them efficiently, it is important to understand the basics of the rendering pipeline. You must also learn how to write GLSL programs and find good tutorials and examples to get started. You can also have a look at the \"Shader\" example that comes with the SFML SDK. This tutorial will only focus on the CrSFML specific part: Loading and applying your shaders -- not writing them.","title":"Introduction"},{"location":"graphics/shader.html#loading-shaders","text":"In CrSFML, shaders are represented by the Shader class. It handles both the vertex and fragment shaders: A Shader object is a combination of both (or only one, if the other is not provided). Even though shaders have become commonplace, there are still old graphics cards that might not support them. The first thing you should do in your program is check if shaders are available on the system: if ! SF :: Shader . available? # shaders are not available... end Any attempt to use the Shader class will fail if SF::Shader.available? returns false . The most common way of loading a shader is from a file on disk, which is done with the from_file class method. # load only the vertex shader shader = SF :: Shader . from_file ( \"vertex_shader.vert\" , SF :: Shader :: Vertex ) # load only the fragment shader shader = SF :: Shader . from_file ( \"fragment_shader.frag\" , SF :: Shader :: Fragment ) # load both shaders shader = SF :: Shader . from_file ( \"vertex_shader.vert\" , \"fragment_shader.frag\" ) Shader source is contained in simple text files (like your Crystal code). Their extension doesn't really matter, it can be anything you want, you can even omit it. \".vert\" and \".frag\" are just examples of possible extensions. The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is: When you run the application from your desktop environment, the working directory is the executable folder. Shaders can also be loaded directly from strings, with the from_memory class method. This can be useful if you want to embed the shader source directly into your program. vertex_shader = \" void main() { ... } \" fragment_shader = \" void main() { ... } \" # load only the vertex shader shader = SF :: Shader . from_memory ( vertex_shader , SF :: Shader :: Vertex ) # load only the fragment shader shader = SF :: Shader . from_memory ( fragment_shader , SF :: Shader :: Fragment ) # load both shaders shader = SF :: Shader . from_memory ( vertex_shader , fragment_shader ) And finally, like all other SFML resources, shaders can also be loaded from a custom input stream with the from_stream class method. If loading fails, don't forget to check the standard error output (the console) to see a detailed report from the GLSL compiler.","title":"Loading shaders"},{"location":"graphics/shader.html#using-a-shader","text":"Using a shader is simple, just pass it as an additional argument to the draw method. window . draw ( whatever , SF :: RenderStates . new ( shader : shader ))","title":"Using a shader"},{"location":"graphics/shader.html#passing-variables-to-a-shader","text":"Like any other program, a shader can take parameters so that it is able to behave differently from one draw to another. These parameters are declared as global variables known as uniforms in the shader. uniform float myvar ; void main () { // use myvar... } Uniforms can be set by the Crystal program, using the various overloads of the set_parameter method in the Shader class. shader . set_parameter ( \"my_var\" , 5.0 ) # shorthand: shader . my_var 5.0 set_parameter 's overloads support all the types provided by CrSFML: Float (GLSL type float ) 2 Float s or SF::Vector2f (GLSL type vec2 ) 3 Float s or SF::Vector3f (GLSL type vec3 ) 4 Float s (GLSL type vec4 ) SF::Color (GLSL type vec4 ) SF::Transform (GLSL type mat4 ) SF::Texture (GLSL type sampler2D ) The GLSL compiler optimizes out unused variables (here, \"unused\" means \"not involved in the calculation of the final vertex/pixel\"). So don't be surprised if you get error messages such as Failed to find variable \"xxx\" in shader when you call set_parameter during your tests.","title":"Passing variables to a shader"},{"location":"graphics/shader.html#minimal-shaders","text":"You won't learn how to write GLSL shaders here, but it is essential that you know what input SFML provides to the shaders and what it expects you to do with it.","title":"Minimal shaders"},{"location":"graphics/shader.html#vertex-shader","text":"SFML has a fixed vertex format which is described by the Vertex structure. A SFML vertex contains a 2D position, a color, and 2D texture coordinates. This is the exact input that you will get in the vertex shader, stored in the built-in gl_Vertex , gl_Color and gl_MultiTexCoord0 variables (you don't need to declare them). void main () { // transform the vertex position gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex ; // transform the texture coordinates gl_TexCoord [ 0 ] = gl_TextureMatrix [ 0 ] * gl_MultiTexCoord0 ; // forward the vertex color gl_FrontColor = gl_Color ; } The position usually needs to be transformed by the model-view and projection matrices, which contain the entity transform combined with the current view. The texture coordinates need to be transformed by the texture matrix (this matrix likely doesn't mean anything to you, it is just an SFML implementation detail). And finally, the color just needs to be forwarded. Of course, you can ignore the texture coordinates and/or the color if you don't make use of them. All these variables will then be interpolated over the primitive by the graphics card, and passed to the fragment shader.","title":"Vertex shader"},{"location":"graphics/shader.html#fragment-shader","text":"The fragment shader functions quite similarly: It receives the texture coordinates and the color of a generated fragment. There's no position any more, at this point the graphics card has already computed the final raster position of the fragment. However if you deal with textured entities, you'll also need the current texture. uniform sampler2D texture ; void main () { // lookup the pixel in the texture vec4 pixel = texture2D ( texture , gl_TexCoord [ 0 ]. xy ); // multiply it by the color gl_FragColor = gl_Color * pixel ; } The current texture is not automatic, you need to treat it like you do the other input variables, and explicitly set it from your C++ program. Since each entity can have a different texture, and worse, there might be no way for you to get it and pass it to the shader, SFML provides a special overload of the set_parameter method that does this job for you. shader.set_parameter \"texture\", SF::Shader::CurrentTexture This special parameter automatically sets the texture of the entity being drawn to the shader variable with the given name. Every time you draw a new entity, SFML will update the shader texture variable accordingly. If you want to see nice examples of shaders in action, you can have a look at the Shader example in the SFML SDK.","title":"Fragment shader"},{"location":"graphics/shader.html#using-a-sfshader-with-opengl-code","text":"If you're using OpenGL rather than the graphics entities of SFML, you can still use Shader as a wrapper around an OpenGL program object and use it within your OpenGL code. To activate a Shader for drawing (the equivalent of glUseProgram ), you have to call the bind class method: shader = SF :: Shader . new ... # bind the shader SF :: Shader . bind ( shader ) # draw your OpenGL entity here... # bind no shader SF :: Shader . bind ( nil )","title":"Using a SF::Shader with OpenGL code"},{"location":"graphics/shape.html","text":"Shapes Introduction CrSFML provides a set of classes that represent simple shape entities. Each type of shape is a separate class, but they all derive from the same base class so that they have access to the same subset of common features. Each class then adds its own specifics: a radius property for the circle class, a size for the rectangle class, points for the polygon class, etc. Common shape properties Transformation (position, rotation, scale) These properties are common to all the CrSFML graphical classes, so they are explained in a separate tutorial: Transforming entities . Color One of the basic properties of a shape is its color. You can change with the fill_color= method. shape = SF :: CircleShape . new ( 50 ) # set the shape color to green shape . fill_color = SF . color ( 100 , 250 , 50 ) Outline Shapes can have an outline. You can set the thickness and color of the outline with the outline_thickness= and outline_color= methods. shape = SF :: CircleShape . new ( 50 ) shape . fill_color = SF . color ( 150 , 50 , 250 ) # set a 10-pixel wide orange outline shape . outline_thickness = 10 shape . outline_color = SF . color ( 250 , 150 , 100 ) By default, the outline is extruded outwards from the shape (e.g. if you have a circle with a radius of 10 and an outline thickness of 5, the total radius of the circle will be 15). You can make it extrude towards the center of the shape instead, by setting a negative thickness. To disable the outline, set its thickness to 0. If you only want the outline, you can set the fill color to SF::Color::Transparent . Texture Shapes can also be textured, just like sprites. To specify a part of the texture to be mapped to the shape, you must use the texture_rect= method. It takes the texture rectangle to map to the bounding rectangle of the shape. This method doesn't offer maximum flexibility, but it is much easier to use than individually setting the texture coordinates of each point of the shape. shape = SF :: CircleShape . new ( 50 ) # map a 100x100 textured rectangle to the shape shape . set_texture ( texture , reset_rect : false ) # texture is a SF::Texture shape . texture_rect = SF . int_rect ( 10 , 10 , 100 , 100 ) Note that the outline is not textured. It is important to know that the texture is modulated (multiplied) with the shape's fill color. If its fill color is SF::Color::White , the texture will appear unmodified. To disable texturing, call set_texture(nil, false) . Drawing a shape Drawing a shape is as simple as drawing any other SFML entity: window . draw ( shape ) Built-in shape types Rectangles To draw rectangles, you can use the RectangleShape class. It has a single attribute: The size of the rectangle. # define a 120x50 rectangle rectangle = SF :: RectangleShape . new ( SF . vector2 ( 120 , 50 )) # change the size to 100x100 rectangle . size = SF . vector2 ( 100 , 100 ) Circles Relevant example: snakes Circles are represented by the CircleShape class. It has two attributes: The radius and the number of sides. The number of sides is an optional attribute, it allows you to adjust the \"quality\" of the circle: Circles have to be approximated by polygons with many sides (the graphics card is unable to draw a perfect circle directly), and this attribute defines how many sides your circle approximation will have. If you draw small circles, you'll probably only need a few sides. If you draw big circles, or zoom on regular circles, you'll most likely need more sides. # define a circle with radius = 200 circle = SF :: CircleShape . new ( 200 ) # change the radius to 40 circle . radius = 40 # change the number of sides (points) to 100 circle . point_count = 100 Regular polygons There's no dedicated class for regular polygons, in fact you can represent a regular polygon with any number of sides using the CircleShape class: Since circles are approximated by polygons with many sides, you just have to play with the number of sides to get the desired polygons. A CircleShape with 3 points is a triangle, with 4 points it's a square, etc. # define a triangle triangle = SF :: CircleShape . new ( 80 , 3 ) # define a square square = SF :: CircleShape . new ( 80 , 4 ) # define an octagon octagon = SF :: CircleShape . new ( 80 , 8 ) Convex shapes Relevant example: rounded_rectangle The ConvexShape class is the ultimate shape class: It allows you to define any convex shape. SFML is unable to draw concave shapes. If you need to draw a concave shape, you'll have to split it into multiple convex polygons. To construct a convex shape, you must first set the number of points it should have and then define the points. # create an empty shape convex = SF :: ConvexShape . new # resize it to 5 points convex . point_count = 5 # define the points convex [ 0 ] = SF . vector2 ( 0 , 0 ) convex [ 1 ] = SF . vector2 ( 150 , 10 ) convex [ 2 ] = SF . vector2 ( 120 , 90 ) convex [ 3 ] = SF . vector2 ( 30 , 100 ) convex [ 4 ] = SF . vector2 ( 0 , 50 ) The order in which you define the points is very important. They must all be defined either in clockwise or counter-clockwise order. If you define them in an inconsistent order, the shape will be constructed incorrectly. Although the name of ConvexShape implies that it should only be used to represent convex shapes, its requirements are a little more relaxed. In fact, the only requirement that your shape must meet is that if you went ahead and drew lines from its center of gravity to all of its points, these lines must be drawn in the same order. You are not allowed to \"jump behind a previous line\". Internally, convex shapes are automatically constructed using triangle fans , so if your shape is representable by a triangle fan, you can use ConvexShape . With this relaxed definition, you can draw stars using ConvexShape for example. Lines There's no shape class for lines. The reason is simple: If your line has a thickness, it is a rectangle. If it doesn't, it can be drawn with a line primitive. Line with thickness: line = SF :: RectangleShape . new ( SF . vector2 ( 150 , 5 )) line . rotate ( 45 ) Line without thickness: line = [ SF :: Vertex . new ( SF . vector2 ( 10 , 10 )), SF :: Vertex . new ( SF . vector2 ( 150 , 150 )) ] window . draw ( line , SF :: Lines ) To learn more about vertices and primitives, you can read the tutorial on vertex arrays . Custom shape types Relevant example: shapes You can extend the set of shape classes with your own shape types. To do so, you must derive from Shape and override two methods: point_count : return the number of points in the shape get_point : return a point of the shape You must also call the update() method whenever any point in your shape changes, so that the base class is informed and can update its internal geometry. Here is a complete example of a custom shape class: EllipseShape . class EllipseShape < SF :: Shape def initialize ( @radius : SF :: Vector2f ) super () update () end def radius @radius end def radius = ( radius : SF :: Vector2f ) @radius = radius update end def point_count 40 # fixed, but could be an attribute of the class if needed end def get_point ( index ) angle = index * 2 * Math :: PI / point_count # origin is {0, 0}, center is @radius @radius + @radius * { Math . cos ( angle ), Math . sin ( angle )} end end Antialiased shapes Relevant example: snakes There's no option to anti-alias a single shape. To get anti-aliased shapes (i.e. shapes with smoothed edges), you have to enable anti-aliasing globally when you create the window, with the corresponding attribute of the structure. window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML shapes\" , settings : SF :: ContextSettings . new ( depth : 24 , antialiasing : 8 ) ) Remember that anti-aliasing availability depends on the graphics card: It might not support it, or have it forced to disabled in the driver settings. Sometimes antialiasing does not work if depth_bits is not specified (use 24 if unsure).","title":"Shapes"},{"location":"graphics/shape.html#shapes","text":"","title":"Shapes"},{"location":"graphics/shape.html#introduction","text":"CrSFML provides a set of classes that represent simple shape entities. Each type of shape is a separate class, but they all derive from the same base class so that they have access to the same subset of common features. Each class then adds its own specifics: a radius property for the circle class, a size for the rectangle class, points for the polygon class, etc.","title":"Introduction"},{"location":"graphics/shape.html#common-shape-properties","text":"","title":"Common shape properties"},{"location":"graphics/shape.html#transformation-position-rotation-scale","text":"These properties are common to all the CrSFML graphical classes, so they are explained in a separate tutorial: Transforming entities .","title":"Transformation (position, rotation, scale)"},{"location":"graphics/shape.html#color","text":"One of the basic properties of a shape is its color. You can change with the fill_color= method. shape = SF :: CircleShape . new ( 50 ) # set the shape color to green shape . fill_color = SF . color ( 100 , 250 , 50 )","title":"Color"},{"location":"graphics/shape.html#outline","text":"Shapes can have an outline. You can set the thickness and color of the outline with the outline_thickness= and outline_color= methods. shape = SF :: CircleShape . new ( 50 ) shape . fill_color = SF . color ( 150 , 50 , 250 ) # set a 10-pixel wide orange outline shape . outline_thickness = 10 shape . outline_color = SF . color ( 250 , 150 , 100 ) By default, the outline is extruded outwards from the shape (e.g. if you have a circle with a radius of 10 and an outline thickness of 5, the total radius of the circle will be 15). You can make it extrude towards the center of the shape instead, by setting a negative thickness. To disable the outline, set its thickness to 0. If you only want the outline, you can set the fill color to SF::Color::Transparent .","title":"Outline"},{"location":"graphics/shape.html#texture","text":"Shapes can also be textured, just like sprites. To specify a part of the texture to be mapped to the shape, you must use the texture_rect= method. It takes the texture rectangle to map to the bounding rectangle of the shape. This method doesn't offer maximum flexibility, but it is much easier to use than individually setting the texture coordinates of each point of the shape. shape = SF :: CircleShape . new ( 50 ) # map a 100x100 textured rectangle to the shape shape . set_texture ( texture , reset_rect : false ) # texture is a SF::Texture shape . texture_rect = SF . int_rect ( 10 , 10 , 100 , 100 ) Note that the outline is not textured. It is important to know that the texture is modulated (multiplied) with the shape's fill color. If its fill color is SF::Color::White , the texture will appear unmodified. To disable texturing, call set_texture(nil, false) .","title":"Texture"},{"location":"graphics/shape.html#drawing-a-shape","text":"Drawing a shape is as simple as drawing any other SFML entity: window . draw ( shape )","title":"Drawing a shape"},{"location":"graphics/shape.html#built-in-shape-types","text":"","title":"Built-in shape types"},{"location":"graphics/shape.html#rectangles","text":"To draw rectangles, you can use the RectangleShape class. It has a single attribute: The size of the rectangle. # define a 120x50 rectangle rectangle = SF :: RectangleShape . new ( SF . vector2 ( 120 , 50 )) # change the size to 100x100 rectangle . size = SF . vector2 ( 100 , 100 )","title":"Rectangles"},{"location":"graphics/shape.html#circles","text":"Relevant example: snakes Circles are represented by the CircleShape class. It has two attributes: The radius and the number of sides. The number of sides is an optional attribute, it allows you to adjust the \"quality\" of the circle: Circles have to be approximated by polygons with many sides (the graphics card is unable to draw a perfect circle directly), and this attribute defines how many sides your circle approximation will have. If you draw small circles, you'll probably only need a few sides. If you draw big circles, or zoom on regular circles, you'll most likely need more sides. # define a circle with radius = 200 circle = SF :: CircleShape . new ( 200 ) # change the radius to 40 circle . radius = 40 # change the number of sides (points) to 100 circle . point_count = 100","title":"Circles"},{"location":"graphics/shape.html#regular-polygons","text":"There's no dedicated class for regular polygons, in fact you can represent a regular polygon with any number of sides using the CircleShape class: Since circles are approximated by polygons with many sides, you just have to play with the number of sides to get the desired polygons. A CircleShape with 3 points is a triangle, with 4 points it's a square, etc. # define a triangle triangle = SF :: CircleShape . new ( 80 , 3 ) # define a square square = SF :: CircleShape . new ( 80 , 4 ) # define an octagon octagon = SF :: CircleShape . new ( 80 , 8 )","title":"Regular polygons"},{"location":"graphics/shape.html#convex-shapes","text":"Relevant example: rounded_rectangle The ConvexShape class is the ultimate shape class: It allows you to define any convex shape. SFML is unable to draw concave shapes. If you need to draw a concave shape, you'll have to split it into multiple convex polygons. To construct a convex shape, you must first set the number of points it should have and then define the points. # create an empty shape convex = SF :: ConvexShape . new # resize it to 5 points convex . point_count = 5 # define the points convex [ 0 ] = SF . vector2 ( 0 , 0 ) convex [ 1 ] = SF . vector2 ( 150 , 10 ) convex [ 2 ] = SF . vector2 ( 120 , 90 ) convex [ 3 ] = SF . vector2 ( 30 , 100 ) convex [ 4 ] = SF . vector2 ( 0 , 50 ) The order in which you define the points is very important. They must all be defined either in clockwise or counter-clockwise order. If you define them in an inconsistent order, the shape will be constructed incorrectly. Although the name of ConvexShape implies that it should only be used to represent convex shapes, its requirements are a little more relaxed. In fact, the only requirement that your shape must meet is that if you went ahead and drew lines from its center of gravity to all of its points, these lines must be drawn in the same order. You are not allowed to \"jump behind a previous line\". Internally, convex shapes are automatically constructed using triangle fans , so if your shape is representable by a triangle fan, you can use ConvexShape . With this relaxed definition, you can draw stars using ConvexShape for example.","title":"Convex shapes"},{"location":"graphics/shape.html#lines","text":"There's no shape class for lines. The reason is simple: If your line has a thickness, it is a rectangle. If it doesn't, it can be drawn with a line primitive. Line with thickness: line = SF :: RectangleShape . new ( SF . vector2 ( 150 , 5 )) line . rotate ( 45 ) Line without thickness: line = [ SF :: Vertex . new ( SF . vector2 ( 10 , 10 )), SF :: Vertex . new ( SF . vector2 ( 150 , 150 )) ] window . draw ( line , SF :: Lines ) To learn more about vertices and primitives, you can read the tutorial on vertex arrays .","title":"Lines"},{"location":"graphics/shape.html#custom-shape-types","text":"Relevant example: shapes You can extend the set of shape classes with your own shape types. To do so, you must derive from Shape and override two methods: point_count : return the number of points in the shape get_point : return a point of the shape You must also call the update() method whenever any point in your shape changes, so that the base class is informed and can update its internal geometry. Here is a complete example of a custom shape class: EllipseShape . class EllipseShape < SF :: Shape def initialize ( @radius : SF :: Vector2f ) super () update () end def radius @radius end def radius = ( radius : SF :: Vector2f ) @radius = radius update end def point_count 40 # fixed, but could be an attribute of the class if needed end def get_point ( index ) angle = index * 2 * Math :: PI / point_count # origin is {0, 0}, center is @radius @radius + @radius * { Math . cos ( angle ), Math . sin ( angle )} end end","title":"Custom shape types"},{"location":"graphics/shape.html#antialiased-shapes","text":"Relevant example: snakes There's no option to anti-alias a single shape. To get anti-aliased shapes (i.e. shapes with smoothed edges), you have to enable anti-aliasing globally when you create the window, with the corresponding attribute of the structure. window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML shapes\" , settings : SF :: ContextSettings . new ( depth : 24 , antialiasing : 8 ) ) Remember that anti-aliasing availability depends on the graphics card: It might not support it, or have it forced to disabled in the driver settings. Sometimes antialiasing does not work if depth_bits is not specified (use 24 if unsure).","title":"Antialiased shapes"},{"location":"graphics/sprite.html","text":"Sprites and textures Relevant example: flippy_bird Vocabulary Most (if not all) of you are already familiar with these two very common objects, so let's define them very briefly. A texture is an image. But we call it \"texture\" because it has a very specific role: being mapped to a 2D entity. A sprite is nothing more than a textured rectangle. Ok, that was short but if you really don't understand what sprites and textures are, then you'll find a much better description on Wikipedia. Loading a texture Before creating any sprite, we need a valid texture. The class that encapsulates textures in CrSFML is, unsurprisingly, Texture . Since the only role of a texture is to be loaded and mapped to graphical entities, almost all its methods are about loading and updating it. The most common way of loading a texture is from an image file on disk, which is done with the from_file class method. texture = SF :: Texture . from_file ( \"image.png\" ) The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is. You can also load an image file from memory ( from_memory ), from a custom input stream ( from_stream ), or from an image that has already been loaded ( from_image ). The latter loads the texture from an Image , which is a utility class that helps store and manipulate image data (modify pixels, create transparency channel, etc.). The pixels of an Image stay in system memory, which ensures that operations on them will be as fast as possible, in contrast to the pixels of a texture which reside in video memory and are therefore slow to retrieve or update but very fast to draw. SFML supports most common image file formats. The full list is available in the API documentation. All these loading class methods have an optional argument, which can be used if you want to load a smaller part of the image. # load a 32x32 rectangle that starts at (10, 10) texture = SF :: Texture . from_file ( \"image.png\" , SF . int_rect ( 10 , 10 , 32 , 32 )) The IntRect class is a simple utility type that represents a rectangle. Its constructor takes the coordinates of the top-left corner, and the size of the rectangle. If you don't want to load a texture from an image, but instead want to update it directly from an array of pixels, you can create it empty and update it later: # create an empty 200x200 texture texture = SF :: Texture . new ( 200 , 200 ) Note that the contents of the texture are undefined at this point. To update the pixels of an existing texture, you have to use the update method. It has overloads for many kinds of data sources: # update a texture from an array of pixels texture . update ( pixels ) # update a texture from a SF::Image texture . update ( image ) # update the texture from the current contents of the window texture . update ( window ) These examples all assume that the source is of the same size as the texture. If this is not the case, i.e. if you want to update only a part of the texture, you can specify the coordinates of the sub-rectangle that you want to update. You can refer to the documentation for further details. Additionally, a texture has two properties that change how it is rendered. The first property allows one to smooth the texture. Smoothing a texture makes pixel boundaries less visible (but the image a little more blurry), which can be desirable if it is up-scaled. texture . smooth = true Since smoothing samples from adjacent pixels in the texture as well, it can lead to the unwanted side effect of factoring in pixels outside the selected texture area. This can happen when your sprite is located at non-integer coordinates. The second property allows a texture to be repeatedly tiled within a single sprite. texture . repeated = true This only works if your sprite is configured to show a rectangle which is larger than the texture, otherwise this property has no effect. Ok, can I have my sprite now? Yes, you can now create your sprite. sprite = SF :: Sprite . new ( texture ) ... and finally draw it. # inside the main loop, between window.clear() and window.display() window . draw ( sprite ) If you don't want your sprite to use the entire texture, you can set its texture rectangle. sprite . texture_rect = SF . int_rect ( 10 , 10 , 32 , 32 ) You can also change the color of a sprite. The color that you set is modulated (multiplied) with the texture of the sprite. This can also be used to change the global transparency (alpha) of the sprite. sprite . color = SF . color ( 0 , 255 , 0 ) # green sprite . color = SF . color ( 255 , 255 , 255 , 128 ) # half transparent These sprites all use the same texture, but have a different color: Sprites can also be transformed: They have a position, an orientation and a scale. # position sprite . position = SF . vector2 ( 10 , 50 ) # absolute position sprite . move ( SF . vector2 ( 5 , 10 )) # offset relative to the current position # rotation sprite . rotation = 90 # absolute angle sprite . rotate ( 15 ) # offset relative to the current angle # scale sprite . scale = SF . vector2 ( 0.5 , 2.0 ) # absolute scale factor sprite . scale ( SF . vector2 ( 1.5 , 3.0 )) # factor relative to the current scale By default, the origin for these three transformations is the top-left corner of the sprite. If you want to set the origin to a different point (for example the center of the sprite, or another corner), you can use the origin= method. sprite . origin = SF . vector2 ( 25 , 25 ) Since transformation methods are common to all CrSFML entities, they are explained in a separate tutorial: Transforming entities . The importance of using as few textures as possible Using as few textures as possible is a good strategy, and the reason is simple: Changing the current texture is an expensive operation for the graphics card. Drawing many sprites that use the same texture will yield the best performance. Additionally, using a single texture allows you to group static geometry into a single entity (you can only use one texture per draw call), which will be much faster to draw than a set of many entities. Batching static geometry involves other classes and is therefore beyond the scope of this tutorial, for further details see the vertex array tutorial. Try to keep this in mind when you create your animation sheets or your tilesets: Use as few textures as possible. Using SF::Texture with OpenGL code If you're using OpenGL rather than the graphics entities of CrSFML, you can still use Texture as a wrapper around an OpenGL texture object and use it along with the rest of your OpenGL code. To bind a Texture for drawing (basically glBindTexture ), you call the bind class method: texture = ... # bind the texture SF :: Texture . bind texture # draw your textured OpenGL entity here... # bind no texture SF :: Texture . bind nil","title":"Sprites and textures"},{"location":"graphics/sprite.html#sprites-and-textures","text":"Relevant example: flippy_bird","title":"Sprites and textures"},{"location":"graphics/sprite.html#vocabulary","text":"Most (if not all) of you are already familiar with these two very common objects, so let's define them very briefly. A texture is an image. But we call it \"texture\" because it has a very specific role: being mapped to a 2D entity. A sprite is nothing more than a textured rectangle. Ok, that was short but if you really don't understand what sprites and textures are, then you'll find a much better description on Wikipedia.","title":"Vocabulary"},{"location":"graphics/sprite.html#loading-a-texture","text":"Before creating any sprite, we need a valid texture. The class that encapsulates textures in CrSFML is, unsurprisingly, Texture . Since the only role of a texture is to be loaded and mapped to graphical entities, almost all its methods are about loading and updating it. The most common way of loading a texture is from an image file on disk, which is done with the from_file class method. texture = SF :: Texture . from_file ( \"image.png\" ) The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is. You can also load an image file from memory ( from_memory ), from a custom input stream ( from_stream ), or from an image that has already been loaded ( from_image ). The latter loads the texture from an Image , which is a utility class that helps store and manipulate image data (modify pixels, create transparency channel, etc.). The pixels of an Image stay in system memory, which ensures that operations on them will be as fast as possible, in contrast to the pixels of a texture which reside in video memory and are therefore slow to retrieve or update but very fast to draw. SFML supports most common image file formats. The full list is available in the API documentation. All these loading class methods have an optional argument, which can be used if you want to load a smaller part of the image. # load a 32x32 rectangle that starts at (10, 10) texture = SF :: Texture . from_file ( \"image.png\" , SF . int_rect ( 10 , 10 , 32 , 32 )) The IntRect class is a simple utility type that represents a rectangle. Its constructor takes the coordinates of the top-left corner, and the size of the rectangle. If you don't want to load a texture from an image, but instead want to update it directly from an array of pixels, you can create it empty and update it later: # create an empty 200x200 texture texture = SF :: Texture . new ( 200 , 200 ) Note that the contents of the texture are undefined at this point. To update the pixels of an existing texture, you have to use the update method. It has overloads for many kinds of data sources: # update a texture from an array of pixels texture . update ( pixels ) # update a texture from a SF::Image texture . update ( image ) # update the texture from the current contents of the window texture . update ( window ) These examples all assume that the source is of the same size as the texture. If this is not the case, i.e. if you want to update only a part of the texture, you can specify the coordinates of the sub-rectangle that you want to update. You can refer to the documentation for further details. Additionally, a texture has two properties that change how it is rendered. The first property allows one to smooth the texture. Smoothing a texture makes pixel boundaries less visible (but the image a little more blurry), which can be desirable if it is up-scaled. texture . smooth = true Since smoothing samples from adjacent pixels in the texture as well, it can lead to the unwanted side effect of factoring in pixels outside the selected texture area. This can happen when your sprite is located at non-integer coordinates. The second property allows a texture to be repeatedly tiled within a single sprite. texture . repeated = true This only works if your sprite is configured to show a rectangle which is larger than the texture, otherwise this property has no effect.","title":"Loading a texture"},{"location":"graphics/sprite.html#ok-can-i-have-my-sprite-now","text":"Yes, you can now create your sprite. sprite = SF :: Sprite . new ( texture ) ... and finally draw it. # inside the main loop, between window.clear() and window.display() window . draw ( sprite ) If you don't want your sprite to use the entire texture, you can set its texture rectangle. sprite . texture_rect = SF . int_rect ( 10 , 10 , 32 , 32 ) You can also change the color of a sprite. The color that you set is modulated (multiplied) with the texture of the sprite. This can also be used to change the global transparency (alpha) of the sprite. sprite . color = SF . color ( 0 , 255 , 0 ) # green sprite . color = SF . color ( 255 , 255 , 255 , 128 ) # half transparent These sprites all use the same texture, but have a different color: Sprites can also be transformed: They have a position, an orientation and a scale. # position sprite . position = SF . vector2 ( 10 , 50 ) # absolute position sprite . move ( SF . vector2 ( 5 , 10 )) # offset relative to the current position # rotation sprite . rotation = 90 # absolute angle sprite . rotate ( 15 ) # offset relative to the current angle # scale sprite . scale = SF . vector2 ( 0.5 , 2.0 ) # absolute scale factor sprite . scale ( SF . vector2 ( 1.5 , 3.0 )) # factor relative to the current scale By default, the origin for these three transformations is the top-left corner of the sprite. If you want to set the origin to a different point (for example the center of the sprite, or another corner), you can use the origin= method. sprite . origin = SF . vector2 ( 25 , 25 ) Since transformation methods are common to all CrSFML entities, they are explained in a separate tutorial: Transforming entities .","title":"Ok, can I have my sprite now?"},{"location":"graphics/sprite.html#the-importance-of-using-as-few-textures-as-possible","text":"Using as few textures as possible is a good strategy, and the reason is simple: Changing the current texture is an expensive operation for the graphics card. Drawing many sprites that use the same texture will yield the best performance. Additionally, using a single texture allows you to group static geometry into a single entity (you can only use one texture per draw call), which will be much faster to draw than a set of many entities. Batching static geometry involves other classes and is therefore beyond the scope of this tutorial, for further details see the vertex array tutorial. Try to keep this in mind when you create your animation sheets or your tilesets: Use as few textures as possible.","title":"The importance of using as few textures as possible"},{"location":"graphics/sprite.html#using-sftexture-with-opengl-code","text":"If you're using OpenGL rather than the graphics entities of CrSFML, you can still use Texture as a wrapper around an OpenGL texture object and use it along with the rest of your OpenGL code. To bind a Texture for drawing (basically glBindTexture ), you call the bind class method: texture = ... # bind the texture SF :: Texture . bind texture # draw your textured OpenGL entity here... # bind no texture SF :: Texture . bind nil","title":"Using SF::Texture with OpenGL code"},{"location":"graphics/text.html","text":"Text and fonts Relevant example: typing Loading a font Before drawing any text, you need to have an available font, just like any other program that prints text. Fonts are encapsulated in the Font class, which provides three main features: loading a font, getting glyphs (i.e. visual characters) from it, and reading its attributes. In a typical program, you'll only have to make use of the first feature, loading the font, so let's focus on that first. The most common way of loading a font is from a file on disk, which is done with the from_file class method. font = SF :: Font . from_file ( \"DejaVuSans.ttf\" ) Note that SFML won't load your system fonts automatically, i.e. SF::Font.from_file(\"Courier New\") won't work. Firstly, because SFML requires file names , not font names, and secondly because SFML doesn't have magical access to your system's font folder. If you want to load a font, you will need to include the font file with your application, just like every other resource (images, sounds, ...). The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is: When you run the application from your desktop environment, the working directory is the executable folder. However, when you launch your program from your IDE (Visual Studio, Code::Blocks, ...) the working directory might sometimes be set to the project directory instead. This can usually be changed quite easily in the project settings. You can also load a font file from memory ( from_memory ), or from a custom input stream ( from_stream ). SFML supports most common font formats. The full list is available in the API documentation. That's all you need to do. Once your font is loaded, you can start drawing text. Drawing text To draw text, you will be using the Text class. It's very simple to use: text = SF :: Text . new # select the font text . font = font # font is a SF::Font # set the string to display text . string = \"Hello world\" # set the character size text . character_size = 24 # in pixels, not points! # set the color text . color = SF :: Color :: Red # set the text style text . style = ( SF :: Text :: Bold | SF :: Text :: Underlined ) ... # inside the main loop, between window.clear() and window.display() window . draw ( text ) Text can also be transformed: They have a position, an orientation and a scale. The methods involved are the same as for the Sprite class and other CrSFML entities. They are explained in the Transforming entities tutorial. Making your own text class If Text is too limited, or if you want to do something else with pre-rendered glyphs, Font provides everything that you need. You can retrieve the texture which contains all the pre-rendered glyphs of a certain size: texture = font . get_texture ( character_size ) It is important to note that glyphs are added to the texture when they are requested. There are so many characters (remember, more than 100000) that they can't all be generated when you load the font. Instead, they are rendered on the fly when you call the get_glyph method (see below). To do something meaningful with the font texture, you must get the texture coordinates of glyphs that are contained in it: glyph = font . get_glyph ( character , character_size , bold ) character is the character, the glyph of which you want to get. You must also specify the character size, and whether you want the bold or the regular version of the glyph. The Glyph structure contains three members: texture_rect contains the texture coordinates of the glyph within the texture bounds contains the bounding rectangle of the glyph, which helps position it relative to the baseline of the text advance is the horizontal offset to apply to get the starting position of the next glyph in the text You can also get some of the font's other metrics, such as the kerning between two characters or the line spacing (always for a certain character size): line_spacing = font . get_line_spacing ( character_size ) kerning = font . get_kerning ( character_1 , character_2 , character_size )","title":"Text and fonts"},{"location":"graphics/text.html#text-and-fonts","text":"Relevant example: typing","title":"Text and fonts"},{"location":"graphics/text.html#loading-a-font","text":"Before drawing any text, you need to have an available font, just like any other program that prints text. Fonts are encapsulated in the Font class, which provides three main features: loading a font, getting glyphs (i.e. visual characters) from it, and reading its attributes. In a typical program, you'll only have to make use of the first feature, loading the font, so let's focus on that first. The most common way of loading a font is from a file on disk, which is done with the from_file class method. font = SF :: Font . from_file ( \"DejaVuSans.ttf\" ) Note that SFML won't load your system fonts automatically, i.e. SF::Font.from_file(\"Courier New\") won't work. Firstly, because SFML requires file names , not font names, and secondly because SFML doesn't have magical access to your system's font folder. If you want to load a font, you will need to include the font file with your application, just like every other resource (images, sounds, ...). The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is: When you run the application from your desktop environment, the working directory is the executable folder. However, when you launch your program from your IDE (Visual Studio, Code::Blocks, ...) the working directory might sometimes be set to the project directory instead. This can usually be changed quite easily in the project settings. You can also load a font file from memory ( from_memory ), or from a custom input stream ( from_stream ). SFML supports most common font formats. The full list is available in the API documentation. That's all you need to do. Once your font is loaded, you can start drawing text.","title":"Loading a font"},{"location":"graphics/text.html#drawing-text","text":"To draw text, you will be using the Text class. It's very simple to use: text = SF :: Text . new # select the font text . font = font # font is a SF::Font # set the string to display text . string = \"Hello world\" # set the character size text . character_size = 24 # in pixels, not points! # set the color text . color = SF :: Color :: Red # set the text style text . style = ( SF :: Text :: Bold | SF :: Text :: Underlined ) ... # inside the main loop, between window.clear() and window.display() window . draw ( text ) Text can also be transformed: They have a position, an orientation and a scale. The methods involved are the same as for the Sprite class and other CrSFML entities. They are explained in the Transforming entities tutorial.","title":"Drawing text"},{"location":"graphics/text.html#making-your-own-text-class","text":"If Text is too limited, or if you want to do something else with pre-rendered glyphs, Font provides everything that you need. You can retrieve the texture which contains all the pre-rendered glyphs of a certain size: texture = font . get_texture ( character_size ) It is important to note that glyphs are added to the texture when they are requested. There are so many characters (remember, more than 100000) that they can't all be generated when you load the font. Instead, they are rendered on the fly when you call the get_glyph method (see below). To do something meaningful with the font texture, you must get the texture coordinates of glyphs that are contained in it: glyph = font . get_glyph ( character , character_size , bold ) character is the character, the glyph of which you want to get. You must also specify the character size, and whether you want the bold or the regular version of the glyph. The Glyph structure contains three members: texture_rect contains the texture coordinates of the glyph within the texture bounds contains the bounding rectangle of the glyph, which helps position it relative to the baseline of the text advance is the horizontal offset to apply to get the starting position of the next glyph in the text You can also get some of the font's other metrics, such as the kerning between two characters or the line spacing (always for a certain character size): line_spacing = font . get_line_spacing ( character_size ) kerning = font . get_kerning ( character_1 , character_2 , character_size )","title":"Making your own text class"},{"location":"graphics/transform.html","text":"Position, rotation, scale: Transforming entities Relevant example: transformable Transforming CrSFML entities All CrSFML classes (sprites, text, shapes) use the same interface for transformations: Transformable . This base class provides a simple API to move, rotate and scale your entities. It doesn't provide maximum flexibility, but instead defines an interface which is easy to understand and to use, and which covers 99% of all use cases -- for the remaining 1%, see the last chapters. Transformable (and all its derived classes) defines four properties: position , rotation , scale and origin . They all have their respective getters and setters. These transformation components are all independent of one another: If you want to change the orientation of the entity, you just have to set its rotation property, you don't have to care about the current position and scale. Position The position is the... position of the entity in the 2D world. I don't think it needs more explanation :). # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute position of the entity entity . position = SF . vector2 ( 10 , 50 ) # move the entity relatively to its current position entity . move ( SF . vector2 ( 5 , 5 )) # retrieve the absolute position of the entity position = entity . position # = (15, 55) By default, entities are positioned relative to their top-left corner. We'll see how to change that with the 'origin' property later. Rotation The rotation is the orientation of the entity in the 2D world. It is defined in degrees , in clockwise order (because the Y axis is pointing down in SFML). # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute rotation of the entity entity . rotation = 45 # rotate the entity relatively to its current orientation entity . rotate ( 10 ) # retrieve the absolute rotation of the entity rotation = entity . rotation # = 55 Note that SFML always returns an angle in range [0, 360) when you call rotation . As with the position, the rotation is performed around the top-left corner by default, but this can be changed by setting the origin. Scale The scale factor allows the entity to be resized. The default scale is 1. Setting it to a value less than 1 makes the entity smaller, greater than 1 makes it bigger. Negative scale values are also allowed, so that you can mirror the entity. # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute scale of the entity entity . scale = SF . vector2 ( 4.0 , 1.6 ) # scale the entity relatively to its current scale entity . scale ( SF . vector2 ( 0.5 , 0.5 )) # retrieve the absolute scale of the entity scale = entity . scale # = (2, 0.8) Origin The origin is the center point of the three other transformations. The entity's position is the position of its origin, its rotation is performed around the origin, and the scale is applied relative to the origin as well. By default, it is the top-left corner of the entity (point (0, 0)), but you can set it to the center of the entity, or any other corner of the entity for example. To keep things simple, there's only a single origin for all three transformation components. This means that you can't position an entity relative to its top-left corner while rotating it around its center for example. If you need to do such things, have a look at the next chapters. # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the origin of the entity entity . origin = SF . vector2 ( 10 , 20 ) # retrieve the origin of the entity origin = entity . origin # = (10, 20) Note that changing the origin also changes where the entity is drawn on screen, even though its position property hasn't changed. If you don't understand why, read this tutorial one more time! Transforming your own classes Transformable is not only made for CrSFML classes, it can also be a base (or a member) of your own classes. class MyGraphicalEntity < SF :: Transformable # ... end entity . position = SF . vector2 ( 10 , 30 ) entity . rotation = 110 entity . scale = SF . vector2 ( 0.5 , 0.2 ) To retrieve the final transform of the entity (commonly needed when drawing it), call the transform method. This method returns a Transform object. See below for an explanation about it, and how to use it to transform an SFML entity. If you don't need/want the complete set of methods provided by the Transformable interface, don't hesitate to simply use it as a member instead and provide your own methods on top of it. It is not abstract, so it is possible to instantiate it instead of only being able to use it as a base class. Custom transforms The Transformable class is easy to use, but it is also limited. Some users might need more flexibility. They might need to specify a final transformation as a custom combination of individual transformations. For these users, a lower-level class is available: Transform . It is nothing more than a 3x3 matrix, so it can represent any transformation in 2D space. There are many ways to construct a Transform : by using the predefined methods for the most common transformations (translation, rotation, scale) by combining two transforms by specifying its 9 elements directly Here are a few examples: # the identity transform (does nothing) t1 = SF :: Transform :: Identity # a rotation transform t2 = SF :: Transform . new t2 . rotate ( 45 ) # a custom matrix t3 = SF :: Transform . new ( 2 , 0 , 20 , 0 , 1 , 50 , 0 , 0 , 1 ) # a combined transform t4 = t1 * t2 * t3 You can apply several predefined transformations to the same transform as well. They will all be combined sequentially: t = SF :: Transform . new t . translate ( 10 , 100 ) t . rotate ( 90 ) t . translate ( - 10 , 50 ) t . scale ( 0.5 , 0.75 ) Back to the point: How can a custom transform be applied to a graphical entity? Simple: Pass it to the draw method. states = SF :: RenderStates . new states . transform = transform window . draw ( entity , states ) If your entity is a Transformable (sprite, text, shape), which contains its own internal transform, both the internal and the passed transform are combined to produce the final transform. Bounding boxes After transforming entities and drawing them, you might want to perform some computations using them e.g. checking for collisions. SFML entities can give you their bounding box. The bounding box is the minimal rectangle that contains all points belonging to the entity, with sides aligned to the X and Y axes. The bounding box is very useful when implementing collision detection: Checks against a point or another axis-aligned rectangle can be done very quickly, and its area is close enough to that of the real entity to provide a good approximation. # get the bounding box of the entity bounding_box = entity . global_bounds # check collision with a point point = ... if bounding_box . contains? point # collision! end # check collision with another box (like the bounding box of another entity) other_box = ... if bounding_box . intersects? other_box # collision! end The method is named global_bounds because it returns the bounding box of the entity in the global coordinate system, i.e. after all of its transformations (position, rotation, scale) have been applied. There's another method that returns the bounding box of the entity in its local coordinate system (before its transformations are applied): local_bounds . This method can be used to get the initial size of an entity, for example, or to perform more specific calculations. Object hierarchies (scene graph) With the custom transforms seen previously, it becomes easy to implement a hierarchy of objects in which children are transformed relative to their parent. All you have to do is pass the combined transform from parent to children when you draw them, all the way until you reach the final drawable entities (sprites, text, shapes, vertex arrays or your own drawables). # the abstract base class class Node # ... methods to transform the node # ... methods to manage the node's children def draw ( target , parent_transform ) # combine the parent transform with the node's one combined_transform = parent_transform * @transform # let the node draw itself on_draw ( target , combined_transform ) # draw its children @children . each do | child | child . draw ( target , combined_transform ) end end private def on_draw ( target , transform ) ... end end # a simple derived class: a node that draws a sprite class SpriteNode < Node # .. methods to define the sprite private def on_draw ( target , transform ) target . draw ( @sprite , transform ) end end","title":"Position, rotation, scale: transforming entities"},{"location":"graphics/transform.html#position-rotation-scale-transforming-entities","text":"Relevant example: transformable","title":"Position, rotation, scale: Transforming entities"},{"location":"graphics/transform.html#transforming-crsfml-entities","text":"All CrSFML classes (sprites, text, shapes) use the same interface for transformations: Transformable . This base class provides a simple API to move, rotate and scale your entities. It doesn't provide maximum flexibility, but instead defines an interface which is easy to understand and to use, and which covers 99% of all use cases -- for the remaining 1%, see the last chapters. Transformable (and all its derived classes) defines four properties: position , rotation , scale and origin . They all have their respective getters and setters. These transformation components are all independent of one another: If you want to change the orientation of the entity, you just have to set its rotation property, you don't have to care about the current position and scale.","title":"Transforming CrSFML entities"},{"location":"graphics/transform.html#position","text":"The position is the... position of the entity in the 2D world. I don't think it needs more explanation :). # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute position of the entity entity . position = SF . vector2 ( 10 , 50 ) # move the entity relatively to its current position entity . move ( SF . vector2 ( 5 , 5 )) # retrieve the absolute position of the entity position = entity . position # = (15, 55) By default, entities are positioned relative to their top-left corner. We'll see how to change that with the 'origin' property later.","title":"Position"},{"location":"graphics/transform.html#rotation","text":"The rotation is the orientation of the entity in the 2D world. It is defined in degrees , in clockwise order (because the Y axis is pointing down in SFML). # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute rotation of the entity entity . rotation = 45 # rotate the entity relatively to its current orientation entity . rotate ( 10 ) # retrieve the absolute rotation of the entity rotation = entity . rotation # = 55 Note that SFML always returns an angle in range [0, 360) when you call rotation . As with the position, the rotation is performed around the top-left corner by default, but this can be changed by setting the origin.","title":"Rotation"},{"location":"graphics/transform.html#scale","text":"The scale factor allows the entity to be resized. The default scale is 1. Setting it to a value less than 1 makes the entity smaller, greater than 1 makes it bigger. Negative scale values are also allowed, so that you can mirror the entity. # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute scale of the entity entity . scale = SF . vector2 ( 4.0 , 1.6 ) # scale the entity relatively to its current scale entity . scale ( SF . vector2 ( 0.5 , 0.5 )) # retrieve the absolute scale of the entity scale = entity . scale # = (2, 0.8)","title":"Scale"},{"location":"graphics/transform.html#origin","text":"The origin is the center point of the three other transformations. The entity's position is the position of its origin, its rotation is performed around the origin, and the scale is applied relative to the origin as well. By default, it is the top-left corner of the entity (point (0, 0)), but you can set it to the center of the entity, or any other corner of the entity for example. To keep things simple, there's only a single origin for all three transformation components. This means that you can't position an entity relative to its top-left corner while rotating it around its center for example. If you need to do such things, have a look at the next chapters. # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the origin of the entity entity . origin = SF . vector2 ( 10 , 20 ) # retrieve the origin of the entity origin = entity . origin # = (10, 20) Note that changing the origin also changes where the entity is drawn on screen, even though its position property hasn't changed. If you don't understand why, read this tutorial one more time!","title":"Origin"},{"location":"graphics/transform.html#transforming-your-own-classes","text":"Transformable is not only made for CrSFML classes, it can also be a base (or a member) of your own classes. class MyGraphicalEntity < SF :: Transformable # ... end entity . position = SF . vector2 ( 10 , 30 ) entity . rotation = 110 entity . scale = SF . vector2 ( 0.5 , 0.2 ) To retrieve the final transform of the entity (commonly needed when drawing it), call the transform method. This method returns a Transform object. See below for an explanation about it, and how to use it to transform an SFML entity. If you don't need/want the complete set of methods provided by the Transformable interface, don't hesitate to simply use it as a member instead and provide your own methods on top of it. It is not abstract, so it is possible to instantiate it instead of only being able to use it as a base class.","title":"Transforming your own classes"},{"location":"graphics/transform.html#custom-transforms","text":"The Transformable class is easy to use, but it is also limited. Some users might need more flexibility. They might need to specify a final transformation as a custom combination of individual transformations. For these users, a lower-level class is available: Transform . It is nothing more than a 3x3 matrix, so it can represent any transformation in 2D space. There are many ways to construct a Transform : by using the predefined methods for the most common transformations (translation, rotation, scale) by combining two transforms by specifying its 9 elements directly Here are a few examples: # the identity transform (does nothing) t1 = SF :: Transform :: Identity # a rotation transform t2 = SF :: Transform . new t2 . rotate ( 45 ) # a custom matrix t3 = SF :: Transform . new ( 2 , 0 , 20 , 0 , 1 , 50 , 0 , 0 , 1 ) # a combined transform t4 = t1 * t2 * t3 You can apply several predefined transformations to the same transform as well. They will all be combined sequentially: t = SF :: Transform . new t . translate ( 10 , 100 ) t . rotate ( 90 ) t . translate ( - 10 , 50 ) t . scale ( 0.5 , 0.75 ) Back to the point: How can a custom transform be applied to a graphical entity? Simple: Pass it to the draw method. states = SF :: RenderStates . new states . transform = transform window . draw ( entity , states ) If your entity is a Transformable (sprite, text, shape), which contains its own internal transform, both the internal and the passed transform are combined to produce the final transform.","title":"Custom transforms"},{"location":"graphics/transform.html#bounding-boxes","text":"After transforming entities and drawing them, you might want to perform some computations using them e.g. checking for collisions. SFML entities can give you their bounding box. The bounding box is the minimal rectangle that contains all points belonging to the entity, with sides aligned to the X and Y axes. The bounding box is very useful when implementing collision detection: Checks against a point or another axis-aligned rectangle can be done very quickly, and its area is close enough to that of the real entity to provide a good approximation. # get the bounding box of the entity bounding_box = entity . global_bounds # check collision with a point point = ... if bounding_box . contains? point # collision! end # check collision with another box (like the bounding box of another entity) other_box = ... if bounding_box . intersects? other_box # collision! end The method is named global_bounds because it returns the bounding box of the entity in the global coordinate system, i.e. after all of its transformations (position, rotation, scale) have been applied. There's another method that returns the bounding box of the entity in its local coordinate system (before its transformations are applied): local_bounds . This method can be used to get the initial size of an entity, for example, or to perform more specific calculations.","title":"Bounding boxes"},{"location":"graphics/transform.html#object-hierarchies-scene-graph","text":"With the custom transforms seen previously, it becomes easy to implement a hierarchy of objects in which children are transformed relative to their parent. All you have to do is pass the combined transform from parent to children when you draw them, all the way until you reach the final drawable entities (sprites, text, shapes, vertex arrays or your own drawables). # the abstract base class class Node # ... methods to transform the node # ... methods to manage the node's children def draw ( target , parent_transform ) # combine the parent transform with the node's one combined_transform = parent_transform * @transform # let the node draw itself on_draw ( target , combined_transform ) # draw its children @children . each do | child | child . draw ( target , combined_transform ) end end private def on_draw ( target , transform ) ... end end # a simple derived class: a node that draws a sprite class SpriteNode < Node # .. methods to define the sprite private def on_draw ( target , transform ) target . draw ( @sprite , transform ) end end","title":"Object hierarchies (scene graph)"},{"location":"graphics/vertex-array.html","text":"Designing your own entities with vertex arrays Introduction SFML provides simple classes for the most common 2D entities. And while more complex entities can easily be created from these building blocks, it isn't always the most efficient solution. For example, you'll reach the limits of your graphics card very quickly if you draw a large number of sprites. The reason is that performance depends in large part on the number of calls to the draw method. Indeed, each call involves setting a set of OpenGL states, resetting matrices, changing textures, etc. All of this is required even when simply drawing two triangles (a sprite). This is far from optimal for your graphics card: Today's GPUs are designed to process large batches of triangles, typically several thousand to millions. To fill this gap, SFML provides a lower-level mechanism to draw things: Vertex arrays. As a matter of fact, vertex arrays are used internally by all other SFML classes. They allow for a more flexible definition of 2D entities, containing as many triangles as you need. They even allow drawing points or lines. What is a vertex, and why are they always in arrays? A vertex is the smallest graphical entity that you can manipulate. In short, it is a graphical point: Naturally, it has a 2D position (x, y), but also a color, and a pair of texture coordinates. We'll go into the roles of these attributes later. Vertices (plural of vertex) alone don't do much. They are always grouped into primitives : Points (1 vertex), lines (2 vertices), triangles (3 vertices) or quads (4 vertices). You can then combine multiple primitives together to create the final geometry of the entity. Now you understand why we always talk about vertex arrays, and not vertices alone. A simple vertex array Let's have a look at the Vertex class now. It's simply a container which contains three public members and no functions besides its constructors. These constructors allow you to construct vertices from the set of attributes you care about -- you don't always need to color or texture your entity. # create a new vertex vertex = SF :: Vertex . new # set its position vertex . position = SF . vector2 ( 10 , 50 ) # set its color vertex . color = SF :: Color :: Red # set its texture coordinates vertex . tex_coords = SF . vector2f ( 100 , 100 ) ... or, using the correct constructor: vertex = SF :: Vertex . new ({ 10 , 50 }, SF :: Color :: Red , { 100 , 100 }) Now, let's define a primitive. Remember, a primitive consists of several vertices, therefore we need a vertex array. CrSFML provides a simple wrapper for this: VertexArray . It provides the semantics of an array, and also stores the type of primitive its vertices define. # create an array of 3 vertices that define a triangle primitive triangle = SF :: VertexArray . new ( SF :: Triangles , 3 ) # define the positions and colors of the triangle's points triangle [ 0 ] = SF :: Vertex . new ( SF . vector2 ( 10 , 10 ), SF :: Color :: Red ) triangle [ 1 ] = SF :: Vertex . new ( SF . vector2 ( 100 , 10 ), SF :: Color :: Blue ) triangle [ 2 ] = SF :: Vertex . new ( SF . vector2 ( 100 , 100 ), SF :: Color :: Green ) # no texture coordinates here, we'll see that later Your triangle is ready and you can now draw it. Drawing a vertex array can be done similar to drawing any other CrSFML entity, by using the draw function: window . draw ( triangle ) You can see that the vertices' color is interpolated to fill the primitive. This is a nice way of creating gradients. Note that you don't have to use the VertexArray class. It's just defined for convenience, it's nothing more than an array along with a SF::PrimitiveType . If you need more flexibility, or a normal (or static) array, you can use your own storage. You must then use the overload of the draw function which takes an array of vertices and the primitive type. vertices = [ SF :: Vertex . new ( ... ), SF :: Vertex . new ( ... ) ] window . draw ( vertices , SF :: Lines ) Primitive types Let's pause for a while and see what kind of primitives you can create. As explained above, you can define the most basic 2D primitives: Point, line, triangle and quad (quad exists merely as a convenience, internally the graphics card breaks it into two triangles). There are also \"chained\" variants of these primitive types which allow for sharing of vertices among two consecutive primitives. This can be useful because consecutive primitives are often connected in some way. Let's have a look at the full list: Primitive type Description Example SF::Points A set of unconnected points. These points have no thickness: They will always occupy a single pixel, regardless of the current transform and view. SF::Lines A set of unconnected lines. These lines have no thickness: They will always be one pixel wide, regardless of the current transform and view. SF::LinesStrip A set of connected lines. The end vertex of one line is used as the start vertex of the next one. SF::Triangles A set of unconnected triangles. SF::TrianglesStrip A set of connected triangles. Each triangle shares its two last vertices with the next one. SF::TrianglesFan A set of triangles connected to a central point. The first vertex is the center, then each new vertex defines a new triangle, using the center and the previous vertex. SF::Quads A set of unconnected quads. The 4 points of each quad must be defined consistently, either in clockwise or counter-clockwise order. Texturing Like other SFML entities, vertex arrays can also be textured. To do so, you'll need to manipulate the tex_coords attribute of the vertices. This attribute defines which pixel of the texture is mapped to the vertex. # create a quad quad = SF :: VertexArray . new ( SF :: Quads , 4 ) # define it as a rectangle, located at (10, 10) and with size 100x100 # define its texture area to be a 25x50 rectangle starting at (0, 0) quad . append SF :: Vertex . new ({ 10 , 10 }, tex_coords : { 0 , 0 }) quad . append SF :: Vertex . new ({ 110 , 10 }, tex_coords : { 25 , 0 }) quad . append SF :: Vertex . new ({ 110 , 110 }, tex_coords : { 25 , 50 }) quad . append SF :: Vertex . new ({ 10 , 110 }, tex_coords : { 0 , 50 }) Texture coordinates are defined in pixels (just like the texture_rect of sprites and shapes). They are not normalized (between 0 and 1), as people who are used to OpenGL programming might expect. Vertex arrays are low-level entities, they only deal with geometry and do not store additional attributes like a texture. To draw a vertex array with a texture, you must pass it directly to the draw method, through a RenderStates object: vertices = ... # SF::VertexArray texture = ... # SF::Texture ... states = SF :: RenderStates . new states . texture = texture window . draw ( vertices , states ) Transforming a vertex array Transforming is similar to texturing. The transform is not stored in the vertex array, you must pass it to the draw method. vertices = ... # SF::VertexArray transform = ... # SF::Transform ... states = SF :: RenderStates . new states . transform = transform window . draw ( vertices , states ) To know more about transformations and the Transform class, you can read the tutorial on transforming entities . Creating an SFML-like entity Now that you know how to define your own textured/colored/transformed entity, wouldn't it be nice to wrap it in an SFML-style class? Fortunately, SFML makes this easy for you by providing the Drawable module and Transformable base class. These two classes are the base of the built-in SFML entities Sprite, Text and Shape. Drawable is an interface: it declares a single abstract method. Including sf::Drawable allows you to draw instances of your class the same way as SFML classes: class MyEntity include SF :: Drawable def draw ( target : SF :: RenderTarget , states : SF :: RenderStates ) end end entity = MyEntity . new window . draw ( entity ) # internally calls entity.draw Subclassing the Transformable class automatically adds the same transformation methods to your class as other CrSFML classes ( position= , rotation= , move , scale , ...). You can learn more about this in the tutorial on transforming entities . Using these two features and a vertex array (in this example we'll also add a texture), here is what a typical CrSFML-like graphical class would look like: class MyEntity < SF :: Transformable include SF :: Drawable # add methods to play with the entity's geometry / colors / texturing... def draw ( target , states ) # apply the entity's transform -- combine it with the one that was passed by the caller states . transform *= transform # transform() is defined by SF::Transformable # apply the texture states . texture = @texture # you may also override states.shader or states.blend_mode if you want # draw the vertex array target . draw ( @vertices , states ) end end You can then use this class as if it were a built-in CrSFML class: entity = MyEntity . new # you can transform it entity . position = SF . vector2 ( 10 , 50 ) entity . rotation = 45 # you can draw it window . draw ( entity ) Example: tile map Relevant example: minesweeper With what we've seen above, let's create a class that encapsulates a tile map. The whole map will be contained in a single vertex array, therefore it will be super fast to draw. Note that we can apply this strategy only if the whole tile set can fit into a single texture. Otherwise, we would have to use at least one vertex array per texture. class TileMap < SF :: Transformable include SF :: Drawable def initialize ( tileset , tile_size , tiles , width , height ) super () # load the tileset texture @tileset = SF :: Texture . from_file ( tileset ) @vertices = SF :: VertexArray . new ( SF :: Quads ) tiles_per_row = @tileset . size . x / tile_size . x # populate the vertex array, with one quad per tile ( 0 ... height ) . each do | y | ( 0 ... width ) . each do | x | # get the current tile number tile_index = tiles [ width * y + x ] # find its position in the tileset texture tile_pos = SF . vector2 ( tile_index % tiles_per_row , tile_index / tiles_per_row ) destination = SF . vector2 ( x , y ) # define its 4 corners and texture coordinates { { 0 , 0 }, { 1 , 0 }, { 1 , 1 }, { 0 , 1 } } . each do | delta | @vertices . append SF :: Vertex . new ( ( destination + delta ) * tile_size , tex_coords : ( tile_pos + delta ) * tile_size ) end end end end def draw ( target , states ) # apply the transform states . transform *= transform () # apply the tileset texture states . texture = @tileset # draw the vertex array target . draw ( @vertices , states ) end end And now, the application that uses it: # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 512 , 256 ), \"Tilemap\" ) # define the level with an array of tile indices level = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 1 , 0 , 0 , 2 , 0 , 3 , 3 , 3 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 3 , 3 , 3 , 0 , 0 , 0 , 1 , 1 , 1 , 2 , 0 , 0 , 0 , 0 , 1 , 0 , 3 , 0 , 2 , 2 , 0 , 0 , 1 , 1 , 1 , 1 , 2 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 2 , 2 , 2 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 3 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] # create the tilemap from the level definition map = TileMap . new ( \"tileset.png\" , SF . vector2 ( 32 , 32 ), level , 16 , 8 ) # run the main loop while window . open? # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed window . close end end # draw the map window . clear window . draw ( map ) window . display end Example: particle system This second example implements another common entity: The particle system. This one is very simple, with no texture and as few parameters as possible. It demonstrates the use of the SF::Points primitive type with a dynamic vertex array which changes every frame. struct Particle def initialize ( @velocity , @lifetime , @position ) @total_lifetime = @lifetime end property velocity : SF :: Vector2f property lifetime : SF :: Time property position : SF :: Vector2f getter total_lifetime : SF :: Time end class ParticleSystem < SF :: Transformable include SF :: Drawable def initialize ( @count : Int32 ) super () @particles = [] of Particle @emitter = SF :: Vector2f . new ( 0.0f32 , 0.0f32 ) @random = Random . new end property emitter def update ( elapsed ) @particles . map! do | p | # update the position of the particle p . position += p . velocity * elapsed . as_seconds # update the particle lifetime p . lifetime -= elapsed # if the particle is dead, remove it if p . lifetime <= SF :: Time :: Zero new_particle else p end end if @particles . size < @count @particles << new_particle end end def draw ( target , states ) vertices = @particles . map do | p | # set the alpha (transparency) of the particle according to its lifetime ratio = p . lifetime / p . total_lifetime color = SF . color ( 255 , 255 , 255 , ( ratio * 255 ) . to_u8 ) SF :: Vertex . new ( p . position , color ) end # apply the transform states . transform *= transform () # draw the vertex array target . draw ( vertices , SF :: Points , states ) end private def new_particle # give a random velocity and lifetime to the particle angle = @random . rand ( Math :: PI * 2 ) speed = @random . rand ( 50.0 .. 100.0 ) velocity = SF . vector2f ( Math . cos ( angle ) * speed , Math . sin ( angle ) * speed ) lifetime = SF . seconds ( @random . rand ( 1.0 .. 3.0 )) Particle . new ( velocity , lifetime , @emitter ) end end And a little demo that uses it: # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"Particles\" ) # create the particle system particles = ParticleSystem . new ( 1000 ) # create a clock to track the elapsed time clock = SF :: Clock . new # run the main loop while window . open? # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed window . close end end # make the particle system emitter follow the mouse mouse = SF :: Mouse . get_position ( window ) particles . emitter = window . map_pixel_to_coords ( mouse ) # update it elapsed = clock . restart particles . update ( elapsed ) # draw it window . clear window . draw ( particles ) window . display end","title":"Designing your own entities with vertex arrays"},{"location":"graphics/vertex-array.html#designing-your-own-entities-with-vertex-arrays","text":"","title":"Designing your own entities with vertex arrays"},{"location":"graphics/vertex-array.html#introduction","text":"SFML provides simple classes for the most common 2D entities. And while more complex entities can easily be created from these building blocks, it isn't always the most efficient solution. For example, you'll reach the limits of your graphics card very quickly if you draw a large number of sprites. The reason is that performance depends in large part on the number of calls to the draw method. Indeed, each call involves setting a set of OpenGL states, resetting matrices, changing textures, etc. All of this is required even when simply drawing two triangles (a sprite). This is far from optimal for your graphics card: Today's GPUs are designed to process large batches of triangles, typically several thousand to millions. To fill this gap, SFML provides a lower-level mechanism to draw things: Vertex arrays. As a matter of fact, vertex arrays are used internally by all other SFML classes. They allow for a more flexible definition of 2D entities, containing as many triangles as you need. They even allow drawing points or lines.","title":"Introduction"},{"location":"graphics/vertex-array.html#what-is-a-vertex-and-why-are-they-always-in-arrays","text":"A vertex is the smallest graphical entity that you can manipulate. In short, it is a graphical point: Naturally, it has a 2D position (x, y), but also a color, and a pair of texture coordinates. We'll go into the roles of these attributes later. Vertices (plural of vertex) alone don't do much. They are always grouped into primitives : Points (1 vertex), lines (2 vertices), triangles (3 vertices) or quads (4 vertices). You can then combine multiple primitives together to create the final geometry of the entity. Now you understand why we always talk about vertex arrays, and not vertices alone.","title":"What is a vertex, and why are they always in arrays?"},{"location":"graphics/vertex-array.html#a-simple-vertex-array","text":"Let's have a look at the Vertex class now. It's simply a container which contains three public members and no functions besides its constructors. These constructors allow you to construct vertices from the set of attributes you care about -- you don't always need to color or texture your entity. # create a new vertex vertex = SF :: Vertex . new # set its position vertex . position = SF . vector2 ( 10 , 50 ) # set its color vertex . color = SF :: Color :: Red # set its texture coordinates vertex . tex_coords = SF . vector2f ( 100 , 100 ) ... or, using the correct constructor: vertex = SF :: Vertex . new ({ 10 , 50 }, SF :: Color :: Red , { 100 , 100 }) Now, let's define a primitive. Remember, a primitive consists of several vertices, therefore we need a vertex array. CrSFML provides a simple wrapper for this: VertexArray . It provides the semantics of an array, and also stores the type of primitive its vertices define. # create an array of 3 vertices that define a triangle primitive triangle = SF :: VertexArray . new ( SF :: Triangles , 3 ) # define the positions and colors of the triangle's points triangle [ 0 ] = SF :: Vertex . new ( SF . vector2 ( 10 , 10 ), SF :: Color :: Red ) triangle [ 1 ] = SF :: Vertex . new ( SF . vector2 ( 100 , 10 ), SF :: Color :: Blue ) triangle [ 2 ] = SF :: Vertex . new ( SF . vector2 ( 100 , 100 ), SF :: Color :: Green ) # no texture coordinates here, we'll see that later Your triangle is ready and you can now draw it. Drawing a vertex array can be done similar to drawing any other CrSFML entity, by using the draw function: window . draw ( triangle ) You can see that the vertices' color is interpolated to fill the primitive. This is a nice way of creating gradients. Note that you don't have to use the VertexArray class. It's just defined for convenience, it's nothing more than an array along with a SF::PrimitiveType . If you need more flexibility, or a normal (or static) array, you can use your own storage. You must then use the overload of the draw function which takes an array of vertices and the primitive type. vertices = [ SF :: Vertex . new ( ... ), SF :: Vertex . new ( ... ) ] window . draw ( vertices , SF :: Lines )","title":"A simple vertex array"},{"location":"graphics/vertex-array.html#primitive-types","text":"Let's pause for a while and see what kind of primitives you can create. As explained above, you can define the most basic 2D primitives: Point, line, triangle and quad (quad exists merely as a convenience, internally the graphics card breaks it into two triangles). There are also \"chained\" variants of these primitive types which allow for sharing of vertices among two consecutive primitives. This can be useful because consecutive primitives are often connected in some way. Let's have a look at the full list: Primitive type Description Example SF::Points A set of unconnected points. These points have no thickness: They will always occupy a single pixel, regardless of the current transform and view. SF::Lines A set of unconnected lines. These lines have no thickness: They will always be one pixel wide, regardless of the current transform and view. SF::LinesStrip A set of connected lines. The end vertex of one line is used as the start vertex of the next one. SF::Triangles A set of unconnected triangles. SF::TrianglesStrip A set of connected triangles. Each triangle shares its two last vertices with the next one. SF::TrianglesFan A set of triangles connected to a central point. The first vertex is the center, then each new vertex defines a new triangle, using the center and the previous vertex. SF::Quads A set of unconnected quads. The 4 points of each quad must be defined consistently, either in clockwise or counter-clockwise order.","title":"Primitive types"},{"location":"graphics/vertex-array.html#texturing","text":"Like other SFML entities, vertex arrays can also be textured. To do so, you'll need to manipulate the tex_coords attribute of the vertices. This attribute defines which pixel of the texture is mapped to the vertex. # create a quad quad = SF :: VertexArray . new ( SF :: Quads , 4 ) # define it as a rectangle, located at (10, 10) and with size 100x100 # define its texture area to be a 25x50 rectangle starting at (0, 0) quad . append SF :: Vertex . new ({ 10 , 10 }, tex_coords : { 0 , 0 }) quad . append SF :: Vertex . new ({ 110 , 10 }, tex_coords : { 25 , 0 }) quad . append SF :: Vertex . new ({ 110 , 110 }, tex_coords : { 25 , 50 }) quad . append SF :: Vertex . new ({ 10 , 110 }, tex_coords : { 0 , 50 }) Texture coordinates are defined in pixels (just like the texture_rect of sprites and shapes). They are not normalized (between 0 and 1), as people who are used to OpenGL programming might expect. Vertex arrays are low-level entities, they only deal with geometry and do not store additional attributes like a texture. To draw a vertex array with a texture, you must pass it directly to the draw method, through a RenderStates object: vertices = ... # SF::VertexArray texture = ... # SF::Texture ... states = SF :: RenderStates . new states . texture = texture window . draw ( vertices , states )","title":"Texturing"},{"location":"graphics/vertex-array.html#transforming-a-vertex-array","text":"Transforming is similar to texturing. The transform is not stored in the vertex array, you must pass it to the draw method. vertices = ... # SF::VertexArray transform = ... # SF::Transform ... states = SF :: RenderStates . new states . transform = transform window . draw ( vertices , states ) To know more about transformations and the Transform class, you can read the tutorial on transforming entities .","title":"Transforming a vertex array"},{"location":"graphics/vertex-array.html#creating-an-sfml-like-entity","text":"Now that you know how to define your own textured/colored/transformed entity, wouldn't it be nice to wrap it in an SFML-style class? Fortunately, SFML makes this easy for you by providing the Drawable module and Transformable base class. These two classes are the base of the built-in SFML entities Sprite, Text and Shape. Drawable is an interface: it declares a single abstract method. Including sf::Drawable allows you to draw instances of your class the same way as SFML classes: class MyEntity include SF :: Drawable def draw ( target : SF :: RenderTarget , states : SF :: RenderStates ) end end entity = MyEntity . new window . draw ( entity ) # internally calls entity.draw Subclassing the Transformable class automatically adds the same transformation methods to your class as other CrSFML classes ( position= , rotation= , move , scale , ...). You can learn more about this in the tutorial on transforming entities . Using these two features and a vertex array (in this example we'll also add a texture), here is what a typical CrSFML-like graphical class would look like: class MyEntity < SF :: Transformable include SF :: Drawable # add methods to play with the entity's geometry / colors / texturing... def draw ( target , states ) # apply the entity's transform -- combine it with the one that was passed by the caller states . transform *= transform # transform() is defined by SF::Transformable # apply the texture states . texture = @texture # you may also override states.shader or states.blend_mode if you want # draw the vertex array target . draw ( @vertices , states ) end end You can then use this class as if it were a built-in CrSFML class: entity = MyEntity . new # you can transform it entity . position = SF . vector2 ( 10 , 50 ) entity . rotation = 45 # you can draw it window . draw ( entity )","title":"Creating an SFML-like entity"},{"location":"graphics/vertex-array.html#example-tile-map","text":"Relevant example: minesweeper With what we've seen above, let's create a class that encapsulates a tile map. The whole map will be contained in a single vertex array, therefore it will be super fast to draw. Note that we can apply this strategy only if the whole tile set can fit into a single texture. Otherwise, we would have to use at least one vertex array per texture. class TileMap < SF :: Transformable include SF :: Drawable def initialize ( tileset , tile_size , tiles , width , height ) super () # load the tileset texture @tileset = SF :: Texture . from_file ( tileset ) @vertices = SF :: VertexArray . new ( SF :: Quads ) tiles_per_row = @tileset . size . x / tile_size . x # populate the vertex array, with one quad per tile ( 0 ... height ) . each do | y | ( 0 ... width ) . each do | x | # get the current tile number tile_index = tiles [ width * y + x ] # find its position in the tileset texture tile_pos = SF . vector2 ( tile_index % tiles_per_row , tile_index / tiles_per_row ) destination = SF . vector2 ( x , y ) # define its 4 corners and texture coordinates { { 0 , 0 }, { 1 , 0 }, { 1 , 1 }, { 0 , 1 } } . each do | delta | @vertices . append SF :: Vertex . new ( ( destination + delta ) * tile_size , tex_coords : ( tile_pos + delta ) * tile_size ) end end end end def draw ( target , states ) # apply the transform states . transform *= transform () # apply the tileset texture states . texture = @tileset # draw the vertex array target . draw ( @vertices , states ) end end And now, the application that uses it: # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 512 , 256 ), \"Tilemap\" ) # define the level with an array of tile indices level = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 1 , 0 , 0 , 2 , 0 , 3 , 3 , 3 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 3 , 3 , 3 , 0 , 0 , 0 , 1 , 1 , 1 , 2 , 0 , 0 , 0 , 0 , 1 , 0 , 3 , 0 , 2 , 2 , 0 , 0 , 1 , 1 , 1 , 1 , 2 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 2 , 2 , 2 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 3 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] # create the tilemap from the level definition map = TileMap . new ( \"tileset.png\" , SF . vector2 ( 32 , 32 ), level , 16 , 8 ) # run the main loop while window . open? # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed window . close end end # draw the map window . clear window . draw ( map ) window . display end","title":"Example: tile map"},{"location":"graphics/vertex-array.html#example-particle-system","text":"This second example implements another common entity: The particle system. This one is very simple, with no texture and as few parameters as possible. It demonstrates the use of the SF::Points primitive type with a dynamic vertex array which changes every frame. struct Particle def initialize ( @velocity , @lifetime , @position ) @total_lifetime = @lifetime end property velocity : SF :: Vector2f property lifetime : SF :: Time property position : SF :: Vector2f getter total_lifetime : SF :: Time end class ParticleSystem < SF :: Transformable include SF :: Drawable def initialize ( @count : Int32 ) super () @particles = [] of Particle @emitter = SF :: Vector2f . new ( 0.0f32 , 0.0f32 ) @random = Random . new end property emitter def update ( elapsed ) @particles . map! do | p | # update the position of the particle p . position += p . velocity * elapsed . as_seconds # update the particle lifetime p . lifetime -= elapsed # if the particle is dead, remove it if p . lifetime <= SF :: Time :: Zero new_particle else p end end if @particles . size < @count @particles << new_particle end end def draw ( target , states ) vertices = @particles . map do | p | # set the alpha (transparency) of the particle according to its lifetime ratio = p . lifetime / p . total_lifetime color = SF . color ( 255 , 255 , 255 , ( ratio * 255 ) . to_u8 ) SF :: Vertex . new ( p . position , color ) end # apply the transform states . transform *= transform () # draw the vertex array target . draw ( vertices , SF :: Points , states ) end private def new_particle # give a random velocity and lifetime to the particle angle = @random . rand ( Math :: PI * 2 ) speed = @random . rand ( 50.0 .. 100.0 ) velocity = SF . vector2f ( Math . cos ( angle ) * speed , Math . sin ( angle ) * speed ) lifetime = SF . seconds ( @random . rand ( 1.0 .. 3.0 )) Particle . new ( velocity , lifetime , @emitter ) end end And a little demo that uses it: # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"Particles\" ) # create the particle system particles = ParticleSystem . new ( 1000 ) # create a clock to track the elapsed time clock = SF :: Clock . new # run the main loop while window . open? # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed window . close end end # make the particle system emitter follow the mouse mouse = SF :: Mouse . get_position ( window ) particles . emitter = window . map_pixel_to_coords ( mouse ) # update it elapsed = clock . restart particles . update ( elapsed ) # draw it window . clear window . draw ( particles ) window . display end","title":"Example: particle system"},{"location":"graphics/view.html","text":"Controlling the 2D camera with views What is a view? In games, it is not uncommon to have levels which are much bigger than the window itself. You only see is a small part of them. This is typically the case in RPGs, platform games, and many other genres. What developers might tend to forget is that they define entities in a 2D world , not directly in the window. The window is just a view, it shows a specific area of the whole world. It is perfectly fine to draw several views of the same world in parallel, or draw the world to a texture rather than to a window. The world itself remains unchanged, what changes is just the way it is seen. Since what is seen in the window is just a small part of the entire 2D world, you need a way to specify which part of the world is shown in the window. Additionally, you may also want to define where/how this area will be shown within the window. These are the two main features of SFML views. To summarize, views are what you need if you want to scroll, rotate or zoom your world. They are also the key to creating split screens and mini-maps. Defining what the view views The class which encapsulates views in SFML is View . It can be constructed directly with a definition of the area to view: # create a view with the rectangular area of the 2D world to show view1 = SF :: View . new ( SF . float_rect ( 200 , 200 , 300 , 200 )) # create a view with its center and size view2 = SF :: View . new ( SF . vector2 ( 350 , 300 ), SF . vector2 ( 300 , 200 )) These two definitions are equivalent: Both views will show the same area of the 2D world, a 300x200 rectangle centered on the point (350, 300). If you don't want to define the view upon construction or want to modify it later, you can use the equivalent setters: view1 . reset ( SF . float_rect ( 200 , 200 , 300 , 200 )) view2 . center = SF . vector2 ( 350 , 300 ) view2 . size = SF . vector2 ( 200 , 200 ) Once your view is defined, you can transform it to make it show a translated/rotated/scaled version of your 2D world. Moving (scrolling) the view Unlike drawable entities, such as sprites or shapes whose positions are defined by their top-left corner (and can be changed to any other point), views are always manipulated by their center -- this is simply more convenient. That's why the method to change the position of a view is named center= , and not position= . # move the view at point (200, 200) view . center = SF . vector2 ( 200 , 200 ) # move the view by an offset of (100, 100) (so its final position is (300, 300)) view . move ( SF . vector2 ( 100 , 100 )) Rotating the view To rotate a view, use the rotation= method. # rotate the view at 20 degrees view . rotation = 20 # rotate the view by 5 degrees relatively to its current orientation (so its final orientation is 25 degrees) view . rotate ( 5 ) Zooming (scaling) the view Zooming in (or out) a view is done through to resizing it, so the method to use is size= . # resize the view to show a 1200x800 area (we see a bigger area, so this is a zoom out) view . size = SF . vector2 ( 1200 , 800 ) # zoom the view relatively to its current size (apply a factor 0.5, so its final size is 600x400) view . zoom ( 0.5 ) Defining how the view is viewed Now that you've defined which part of the 2D world is seen in the window, let's define where it is shown. By default, the viewed contents occupy the full window. If the view has the same size as the window, everything is rendered 1:1. If the view is smaller or larger than the window, everything is scaled to fit in the window. This default behavior is suitable for most situations, but it might need to be changed sometimes. For example, to split the screen in a multiplayer game, you may want to use two views which each only occupy half of the window. You can also implement a minimap by drawing your entire world to a view which is rendered in a small area in a corner of the window. The area in which the contents of the view is shown is called the viewport . To set the viewport of a view, you can use the viewport= method. # define a centered viewport, with half the size of the window view . viewport = SF . float_rect ( 0.25 , 0.25 , 0.5 , 0.5 ) You might have noticed something very important: The viewport is not defined in pixels, but instead as a ratio of the window size. This is more convenient: It allows you to not have to track resize events in order to update the size of the viewport every time the size of the window changes. It is also more intuitive: You would probably define your viewport as a fraction of the entire window area anyway, not as a fixed-size rectangle. Using a viewport, it is straightforward to split the screen for multiplayer games: # player 1 (left side of the screen) player1_view . viewport = SF . float_rect ( 0 , 0 , 0.5 , 1 ) # player 2 (right side of the screen) player2_view . viewport = SF . float_rect ( 0.5 , 0 , 0.5 , 1 ) ... or a mini-map: # the game view (full window) game_view . viewport = SF . float_rect ( 0 , 0 , 1 , 1 ) # mini-map (upper-right corner) minimap_view . viewport = SF . float_rect ( 0.75 , 0 , 0.25 , 0.25 ) Using a view To draw something using a view, you must draw it after calling the view= method of the target to which you are drawing ( RenderWindow or RenderTexture ). # let's define a view view = SF :: View . new ( SF . float_rect ( 0 , 0 , 1000 , 600 )) # activate it window . view = view # draw something to that view window . draw ( some_sprite ) # want to do visibility checks? retrieve the view current_view = window . view ... The view remains active until you set another one. This means that there is always a view which defines what appears in the target, and where it is drawn. If you don't explicitly set any view, the render-target uses its own default view, which matches its size 1:1. You can get the default view of a render-target with the default_view method. This can be useful if you want to define your own view based on it, or restore it to draw fixed entities (like a GUI) on top of your scene. # create a view half the size of the default view view = window . default_view view . zoom ( 0.5 ) window . view = view # restore the default view window . view = window . default_view When you call view= , the render-target makes a copy of the view, and doesn't store a pointer to the one that is passed. This means that whenever you update your view, you need to call view= again to apply the modifications. Don't be afraid to copy views or create them on the fly, they aren't expensive objects (they just hold a few floats). Showing more when the window is resized Since the default view never changes after the window is created, the viewed contents are always the same. So when the window is resized, everything is squeezed/stretched to the new size. If, instead of this default behavior, you'd like to show more/less stuff depending on the new size of the window, all you have to do is update the size of the view with the size of the window. # the event loop while event = window . poll_event ... # catch the resize events if event . is_a? SF :: Event :: Resized # update the view to the new size of the window visible_area = SF . float_rect ( 0 , 0 , event . width , event . height ) window . view = SF :: View . new ( visible_area ) end end Coordinates conversions When you use a custom view, or when you resize the window without using the code above, pixels displayed on the target no longer match units in the 2D world. For example, clicking on pixel (10, 50) may hit the point (26.5, -84) of your world. You end up having to use a conversion method to map your pixel coordinates to world coordinates: map_pixel_to_coords . # get the current mouse position in the window pixel_pos = SF :: Mouse . get_position ( window ) # convert it to world coordinates world_pos = window . map_pixel_to_coords ( pixel_pos , window . view ) By default, map_pixel_to_coords uses the current view. If you want to convert the coordinates using view which is not the active one, you can pass it as an additional argument to the method. The opposite, converting world coordinates to pixel coordinates, is also possible with the map_coords_to_pixel method.","title":"Controlling the 2D camera with views"},{"location":"graphics/view.html#controlling-the-2d-camera-with-views","text":"","title":"Controlling the 2D camera with views"},{"location":"graphics/view.html#what-is-a-view","text":"In games, it is not uncommon to have levels which are much bigger than the window itself. You only see is a small part of them. This is typically the case in RPGs, platform games, and many other genres. What developers might tend to forget is that they define entities in a 2D world , not directly in the window. The window is just a view, it shows a specific area of the whole world. It is perfectly fine to draw several views of the same world in parallel, or draw the world to a texture rather than to a window. The world itself remains unchanged, what changes is just the way it is seen. Since what is seen in the window is just a small part of the entire 2D world, you need a way to specify which part of the world is shown in the window. Additionally, you may also want to define where/how this area will be shown within the window. These are the two main features of SFML views. To summarize, views are what you need if you want to scroll, rotate or zoom your world. They are also the key to creating split screens and mini-maps.","title":"What is a view?"},{"location":"graphics/view.html#defining-what-the-view-views","text":"The class which encapsulates views in SFML is View . It can be constructed directly with a definition of the area to view: # create a view with the rectangular area of the 2D world to show view1 = SF :: View . new ( SF . float_rect ( 200 , 200 , 300 , 200 )) # create a view with its center and size view2 = SF :: View . new ( SF . vector2 ( 350 , 300 ), SF . vector2 ( 300 , 200 )) These two definitions are equivalent: Both views will show the same area of the 2D world, a 300x200 rectangle centered on the point (350, 300). If you don't want to define the view upon construction or want to modify it later, you can use the equivalent setters: view1 . reset ( SF . float_rect ( 200 , 200 , 300 , 200 )) view2 . center = SF . vector2 ( 350 , 300 ) view2 . size = SF . vector2 ( 200 , 200 ) Once your view is defined, you can transform it to make it show a translated/rotated/scaled version of your 2D world.","title":"Defining what the view views"},{"location":"graphics/view.html#moving-scrolling-the-view","text":"Unlike drawable entities, such as sprites or shapes whose positions are defined by their top-left corner (and can be changed to any other point), views are always manipulated by their center -- this is simply more convenient. That's why the method to change the position of a view is named center= , and not position= . # move the view at point (200, 200) view . center = SF . vector2 ( 200 , 200 ) # move the view by an offset of (100, 100) (so its final position is (300, 300)) view . move ( SF . vector2 ( 100 , 100 ))","title":"Moving (scrolling) the view"},{"location":"graphics/view.html#rotating-the-view","text":"To rotate a view, use the rotation= method. # rotate the view at 20 degrees view . rotation = 20 # rotate the view by 5 degrees relatively to its current orientation (so its final orientation is 25 degrees) view . rotate ( 5 )","title":"Rotating the view"},{"location":"graphics/view.html#zooming-scaling-the-view","text":"Zooming in (or out) a view is done through to resizing it, so the method to use is size= . # resize the view to show a 1200x800 area (we see a bigger area, so this is a zoom out) view . size = SF . vector2 ( 1200 , 800 ) # zoom the view relatively to its current size (apply a factor 0.5, so its final size is 600x400) view . zoom ( 0.5 )","title":"Zooming (scaling) the view"},{"location":"graphics/view.html#defining-how-the-view-is-viewed","text":"Now that you've defined which part of the 2D world is seen in the window, let's define where it is shown. By default, the viewed contents occupy the full window. If the view has the same size as the window, everything is rendered 1:1. If the view is smaller or larger than the window, everything is scaled to fit in the window. This default behavior is suitable for most situations, but it might need to be changed sometimes. For example, to split the screen in a multiplayer game, you may want to use two views which each only occupy half of the window. You can also implement a minimap by drawing your entire world to a view which is rendered in a small area in a corner of the window. The area in which the contents of the view is shown is called the viewport . To set the viewport of a view, you can use the viewport= method. # define a centered viewport, with half the size of the window view . viewport = SF . float_rect ( 0.25 , 0.25 , 0.5 , 0.5 ) You might have noticed something very important: The viewport is not defined in pixels, but instead as a ratio of the window size. This is more convenient: It allows you to not have to track resize events in order to update the size of the viewport every time the size of the window changes. It is also more intuitive: You would probably define your viewport as a fraction of the entire window area anyway, not as a fixed-size rectangle. Using a viewport, it is straightforward to split the screen for multiplayer games: # player 1 (left side of the screen) player1_view . viewport = SF . float_rect ( 0 , 0 , 0.5 , 1 ) # player 2 (right side of the screen) player2_view . viewport = SF . float_rect ( 0.5 , 0 , 0.5 , 1 ) ... or a mini-map: # the game view (full window) game_view . viewport = SF . float_rect ( 0 , 0 , 1 , 1 ) # mini-map (upper-right corner) minimap_view . viewport = SF . float_rect ( 0.75 , 0 , 0.25 , 0.25 )","title":"Defining how the view is viewed"},{"location":"graphics/view.html#using-a-view","text":"To draw something using a view, you must draw it after calling the view= method of the target to which you are drawing ( RenderWindow or RenderTexture ). # let's define a view view = SF :: View . new ( SF . float_rect ( 0 , 0 , 1000 , 600 )) # activate it window . view = view # draw something to that view window . draw ( some_sprite ) # want to do visibility checks? retrieve the view current_view = window . view ... The view remains active until you set another one. This means that there is always a view which defines what appears in the target, and where it is drawn. If you don't explicitly set any view, the render-target uses its own default view, which matches its size 1:1. You can get the default view of a render-target with the default_view method. This can be useful if you want to define your own view based on it, or restore it to draw fixed entities (like a GUI) on top of your scene. # create a view half the size of the default view view = window . default_view view . zoom ( 0.5 ) window . view = view # restore the default view window . view = window . default_view When you call view= , the render-target makes a copy of the view, and doesn't store a pointer to the one that is passed. This means that whenever you update your view, you need to call view= again to apply the modifications. Don't be afraid to copy views or create them on the fly, they aren't expensive objects (they just hold a few floats).","title":"Using a view"},{"location":"graphics/view.html#showing-more-when-the-window-is-resized","text":"Since the default view never changes after the window is created, the viewed contents are always the same. So when the window is resized, everything is squeezed/stretched to the new size. If, instead of this default behavior, you'd like to show more/less stuff depending on the new size of the window, all you have to do is update the size of the view with the size of the window. # the event loop while event = window . poll_event ... # catch the resize events if event . is_a? SF :: Event :: Resized # update the view to the new size of the window visible_area = SF . float_rect ( 0 , 0 , event . width , event . height ) window . view = SF :: View . new ( visible_area ) end end","title":"Showing more when the window is resized"},{"location":"graphics/view.html#coordinates-conversions","text":"When you use a custom view, or when you resize the window without using the code above, pixels displayed on the target no longer match units in the 2D world. For example, clicking on pixel (10, 50) may hit the point (26.5, -84) of your world. You end up having to use a conversion method to map your pixel coordinates to world coordinates: map_pixel_to_coords . # get the current mouse position in the window pixel_pos = SF :: Mouse . get_position ( window ) # convert it to world coordinates world_pos = window . map_pixel_to_coords ( pixel_pos , window . view ) By default, map_pixel_to_coords uses the current view. If you want to convert the coordinates using view which is not the active one, you can pass it as an additional argument to the method. The opposite, converting world coordinates to pixel coordinates, is also possible with the map_coords_to_pixel method.","title":"Coordinates conversions"},{"location":"network/ftp.html","text":"File transfers with FTP FTP for dummies If you know what FTP is, and just want to know how to use the FTP class that SFML provides, you can skip this section. FTP ( File Transfer Protocol ) is a simple protocol that allows manipulation of files and directories on a remote server. The protocol consists of commands such as \"create directory\", \"delete file\", \"download file\", etc. You can't send FTP commands to any remote computer, it needs to have an FTP server running which can understand and execute the commands that clients send. So what can you do with FTP, and how can it be helpful to your program? Basically, with FTP you can access existing remote file systems, or even create your own. This can be useful if you want your network game to download resources (maps, images, ...) from a server, or your program to update itself automatically when it's connected to the internet. If you want to know more about the FTP protocol, the Wikipedia article provides more detailed information than this short introduction. The FTP client class The class provided by CrSFML is Ftp (surprising, isn't it?). It's a client, which means that it can connect to an FTP server, send commands to it and upload or download files. Every method of the Ftp class wraps an FTP command, and returns a standard FTP response. An FTP response contains a status code (similar to HTTP status codes but not identical), and a message that informs the user of what happened. FTP responses are encapsulated in the Ftp::Response class. ftp = SF :: Ftp . new ... response = ftp . login ( \"username\" , \"password\" ) # just an example, could be any method puts \"Response status: #{ response . status } \" puts \"Response message: #{ response . message } \" The status code can be used to check whether the command was successful or failed: Codes lower than 400 represent success, all others represent errors. You can use the ok? method as a shortcut to test a status code for success. response = ftp . login ( \"username\" , \"password\" ) if response . ok? # success! else # error... end If you don't care about the details of the response, you can check for success with even less code: if ftp . login ( \"username\" , \"password\" ) . ok? # success! else # error... end For readability, these checks won't be performed in the following examples in this tutorial. Don't forget to perform them in your code! Now that you understand how the class works, let's have a look at what it can do. Connecting to the FTP server The first thing to do is connect to an FTP server. ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address ) The server address can be any valid IpAddress : A URL, an IP address, a network name, ... The standard port for FTP is 21. If, for some reason, your server uses a different port, you can specify it as an additional argument: ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address , 45000 ) You can also pass a third parameter, which is a time out value. This prevents you from having to wait forever (or at least a very long time) if the server doesn't respond. ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address , 21 , SF . seconds ( 5 )) Once you're connected to the server, the next step is to authenticate yourself: # authenticate with name and password ftp . login ( \"username\" , \"password\" ) # or login anonymously, if the server allows it ftp . login FTP commands Here is a short description of all the commands available in the Ftp class. Remember one thing: All these commands are performed relative to the current working directory , exactly as if you were executing file or directory commands in a console on your operating system. Getting the current working directory: response = ftp . working_directory if response . ok? puts \"Current directory: \" + response . directory end Ftp::DirectoryResponse is a specialized Ftp::Response that also contains the requested directory. Getting the list of directories and files contained in the current directory: response = ftp . get_directory_listing if response . ok? listing = response . listing listing . each do | item | puts \"- \" + item end end # you can also get the listing of a sub-directory of the current directory: response = ftp . get_directory_listing ( \"subfolder\" ) Ftp::ListingResponse is a specialized Ftp::Response that also contains the requested directory/file names. Changing the current directory: ftp . change_directory ( \"path/to/new_directory\" ) # the given path is relative to the current directory Going to the parent directory of the current one: ftp . parent_directory Creating a new directory (as a child of the current one): ftp . create_directory ( \"name_of_new_directory\" ) Deleting an existing directory: ftp . delete_directory ( \"name_of_directory_to_delete\" ) Renaming an existing file: ftp . rename_file ( \"old_name.txt\" , \"new_name.txt\" ) Deleting an existing file: ftp . delete_file ( \"file_name.txt\" ) Downloading (receiving from the server) a file: ftp . download ( \"remote_file_name.txt\" , \"local/destination/path\" , SF :: Ftp :: Ascii ) The last argument is the transfer mode. It can be either Ascii (for text files), Ebcdic (for text files using the EBCDIC character set) or Binary (for non-text files). The Ascii and Ebcdic modes can transform the file (line endings, encoding) during the transfer to match the client environment. The Binary mode is a direct byte-for-byte transfer. Uploading (sending to the server) a file: ftp . upload ( \"local_file_name.pdf\" , \"remote/destination/path\" , SF :: Ftp :: Binary ) FTP servers usually close connections that are inactive for a while. If you want to avoid being disconnected, you can send a no-op command periodically: ftp . keep_alive () Disconnecting from the FTP server You can close the connection with the server at any moment with the disconnect method. ftp . disconnect ()","title":"File transfers with FTP"},{"location":"network/ftp.html#file-transfers-with-ftp","text":"","title":"File transfers with FTP"},{"location":"network/ftp.html#ftp-for-dummies","text":"If you know what FTP is, and just want to know how to use the FTP class that SFML provides, you can skip this section. FTP ( File Transfer Protocol ) is a simple protocol that allows manipulation of files and directories on a remote server. The protocol consists of commands such as \"create directory\", \"delete file\", \"download file\", etc. You can't send FTP commands to any remote computer, it needs to have an FTP server running which can understand and execute the commands that clients send. So what can you do with FTP, and how can it be helpful to your program? Basically, with FTP you can access existing remote file systems, or even create your own. This can be useful if you want your network game to download resources (maps, images, ...) from a server, or your program to update itself automatically when it's connected to the internet. If you want to know more about the FTP protocol, the Wikipedia article provides more detailed information than this short introduction.","title":"FTP for dummies"},{"location":"network/ftp.html#the-ftp-client-class","text":"The class provided by CrSFML is Ftp (surprising, isn't it?). It's a client, which means that it can connect to an FTP server, send commands to it and upload or download files. Every method of the Ftp class wraps an FTP command, and returns a standard FTP response. An FTP response contains a status code (similar to HTTP status codes but not identical), and a message that informs the user of what happened. FTP responses are encapsulated in the Ftp::Response class. ftp = SF :: Ftp . new ... response = ftp . login ( \"username\" , \"password\" ) # just an example, could be any method puts \"Response status: #{ response . status } \" puts \"Response message: #{ response . message } \" The status code can be used to check whether the command was successful or failed: Codes lower than 400 represent success, all others represent errors. You can use the ok? method as a shortcut to test a status code for success. response = ftp . login ( \"username\" , \"password\" ) if response . ok? # success! else # error... end If you don't care about the details of the response, you can check for success with even less code: if ftp . login ( \"username\" , \"password\" ) . ok? # success! else # error... end For readability, these checks won't be performed in the following examples in this tutorial. Don't forget to perform them in your code! Now that you understand how the class works, let's have a look at what it can do.","title":"The FTP client class"},{"location":"network/ftp.html#connecting-to-the-ftp-server","text":"The first thing to do is connect to an FTP server. ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address ) The server address can be any valid IpAddress : A URL, an IP address, a network name, ... The standard port for FTP is 21. If, for some reason, your server uses a different port, you can specify it as an additional argument: ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address , 45000 ) You can also pass a third parameter, which is a time out value. This prevents you from having to wait forever (or at least a very long time) if the server doesn't respond. ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address , 21 , SF . seconds ( 5 )) Once you're connected to the server, the next step is to authenticate yourself: # authenticate with name and password ftp . login ( \"username\" , \"password\" ) # or login anonymously, if the server allows it ftp . login","title":"Connecting to the FTP server"},{"location":"network/ftp.html#ftp-commands","text":"Here is a short description of all the commands available in the Ftp class. Remember one thing: All these commands are performed relative to the current working directory , exactly as if you were executing file or directory commands in a console on your operating system. Getting the current working directory: response = ftp . working_directory if response . ok? puts \"Current directory: \" + response . directory end Ftp::DirectoryResponse is a specialized Ftp::Response that also contains the requested directory. Getting the list of directories and files contained in the current directory: response = ftp . get_directory_listing if response . ok? listing = response . listing listing . each do | item | puts \"- \" + item end end # you can also get the listing of a sub-directory of the current directory: response = ftp . get_directory_listing ( \"subfolder\" ) Ftp::ListingResponse is a specialized Ftp::Response that also contains the requested directory/file names. Changing the current directory: ftp . change_directory ( \"path/to/new_directory\" ) # the given path is relative to the current directory Going to the parent directory of the current one: ftp . parent_directory Creating a new directory (as a child of the current one): ftp . create_directory ( \"name_of_new_directory\" ) Deleting an existing directory: ftp . delete_directory ( \"name_of_directory_to_delete\" ) Renaming an existing file: ftp . rename_file ( \"old_name.txt\" , \"new_name.txt\" ) Deleting an existing file: ftp . delete_file ( \"file_name.txt\" ) Downloading (receiving from the server) a file: ftp . download ( \"remote_file_name.txt\" , \"local/destination/path\" , SF :: Ftp :: Ascii ) The last argument is the transfer mode. It can be either Ascii (for text files), Ebcdic (for text files using the EBCDIC character set) or Binary (for non-text files). The Ascii and Ebcdic modes can transform the file (line endings, encoding) during the transfer to match the client environment. The Binary mode is a direct byte-for-byte transfer. Uploading (sending to the server) a file: ftp . upload ( \"local_file_name.pdf\" , \"remote/destination/path\" , SF :: Ftp :: Binary ) FTP servers usually close connections that are inactive for a while. If you want to avoid being disconnected, you can send a no-op command periodically: ftp . keep_alive ()","title":"FTP commands"},{"location":"network/ftp.html#disconnecting-from-the-ftp-server","text":"You can close the connection with the server at any moment with the disconnect method. ftp . disconnect ()","title":"Disconnecting from the FTP server"},{"location":"network/http.html","text":"Web requests with HTTP Relevant example: shader Introduction CrSFML provides a simple HTTP client class which you can use to communicate with HTTP servers. \"Simple\" means that it supports the most basic features of HTTP: POST, GET and HEAD request types, accessing HTTP header fields, and reading/writing the pages body. If you need more advanced features, such as secured HTTP (HTTPS) for example, you're better off using a true HTTP library. For basic interaction between your program and an HTTP server, it should be enough. SF::Http To communicate with an HTTP server you must use the Http class. http = SF :: Http . new http . set_host ( \"http://example.org/\" ) # or http = SF :: Http . new ( \"http://example.org/\" ) Note that setting the host doesn't trigger any connection. A temporary connection is created for each request. The only other method in Http , sends requests. This is basically all that the class does. request = SF :: Http :: Request . new # fill the request... response = http . send_request ( request ) Requests An HTTP request, represented by the Http::Request class, contains the following information: The method: POST (send content), GET (retrieve a resource), HEAD (retrieve a resource header, without its body) The URI: the address of the resource (page, image, ...) to get/post, relative to the root directory The HTTP version (it is 1.0 by default but you can choose a different version if you use specific features) The header: a set of fields with key and value The body of the page (used only with the POST method) request = SF :: Http :: Request . new request . method = SF :: Http :: Request :: Post request . uri = \"/index.html\" request . set_http_version ( 1 , 1 ) # HTTP 1.1 request . set_field ( \"From\" , \"me\" ) request . set_field ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) request . body = \"para1=value1&param2=value2\" response = http . send_request ( request ) SFML automatically fills mandatory header fields, such as \"Host\", \"Content-Length\", etc. You can send your requests without worrying about them. SFML will do its best to make sure they are valid. Responses If the Http class could successfully connect to the host and send the request, a response is sent back and returned to the user, encapsulated in an instance of the Http::Response class. Responses contain the following members: A status code which precisely indicates how the server processed the request (OK, redirected, not found, etc.) The HTTP version of the server The header: a set of fields with key and value The body of the response response = http . send_request ( request ) puts \"Status: #{ response . status } \" puts \"HTTP version: #{ response . major_http_version } . #{ response . minor_http_version } \" puts \"Content-Type header: \" + response . get_field ( \"Content-Type\" ) puts \"Body: \\n \" + response . body The status code can be used to check whether the request was successfully processed or not: codes 2xx represent success, codes 3xx represent a redirection, codes 4xx represent client errors, codes 5xx represent server errors, and codes 10xx represent SFML specific errors which are not part of the HTTP standard. Example: sending scores to an online server Here is a short example that demonstrates how to perform a simple task: Sending a score to an online database. def send_score ( score , name ) # prepare the request request = SF :: Http :: Request . new ( \"/send-score.html\" , SF :: Http :: Request :: Post ) # encode the parameters in the request body request . body = \"name=\" + name + \"&score=\" + score # send the request http = SF :: Http . new ( \"http://www.myserver.com/\" ) response = http . send_request ( request ) # check the status if response . status . ok? # check the contents of the response puts response . body else puts \"request failed\" end end Of course, this is a very simple way to handle online scores. There's no protection: Anybody could easily send a false score. A more robust approach would probably involve an extra parameter, like a hash code that ensures that the request was sent by the program. That is beyond the scope of this tutorial. And finally, here is a very simple example of what the PHP page on server might look like. <?php $name = $_POST [ 'name' ]; $score = $_POST [ 'score' ]; if ( write_to_database ( $name , $score )) { // this is not a PHP tutorial :) echo 'name and score added!' ; } else { echo 'failed to write name and score to database...' ; }","title":"Web requests with HTTP"},{"location":"network/http.html#web-requests-with-http","text":"Relevant example: shader","title":"Web requests with HTTP"},{"location":"network/http.html#introduction","text":"CrSFML provides a simple HTTP client class which you can use to communicate with HTTP servers. \"Simple\" means that it supports the most basic features of HTTP: POST, GET and HEAD request types, accessing HTTP header fields, and reading/writing the pages body. If you need more advanced features, such as secured HTTP (HTTPS) for example, you're better off using a true HTTP library. For basic interaction between your program and an HTTP server, it should be enough.","title":"Introduction"},{"location":"network/http.html#sfhttp","text":"To communicate with an HTTP server you must use the Http class. http = SF :: Http . new http . set_host ( \"http://example.org/\" ) # or http = SF :: Http . new ( \"http://example.org/\" ) Note that setting the host doesn't trigger any connection. A temporary connection is created for each request. The only other method in Http , sends requests. This is basically all that the class does. request = SF :: Http :: Request . new # fill the request... response = http . send_request ( request )","title":"SF::Http"},{"location":"network/http.html#requests","text":"An HTTP request, represented by the Http::Request class, contains the following information: The method: POST (send content), GET (retrieve a resource), HEAD (retrieve a resource header, without its body) The URI: the address of the resource (page, image, ...) to get/post, relative to the root directory The HTTP version (it is 1.0 by default but you can choose a different version if you use specific features) The header: a set of fields with key and value The body of the page (used only with the POST method) request = SF :: Http :: Request . new request . method = SF :: Http :: Request :: Post request . uri = \"/index.html\" request . set_http_version ( 1 , 1 ) # HTTP 1.1 request . set_field ( \"From\" , \"me\" ) request . set_field ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) request . body = \"para1=value1&param2=value2\" response = http . send_request ( request ) SFML automatically fills mandatory header fields, such as \"Host\", \"Content-Length\", etc. You can send your requests without worrying about them. SFML will do its best to make sure they are valid.","title":"Requests"},{"location":"network/http.html#responses","text":"If the Http class could successfully connect to the host and send the request, a response is sent back and returned to the user, encapsulated in an instance of the Http::Response class. Responses contain the following members: A status code which precisely indicates how the server processed the request (OK, redirected, not found, etc.) The HTTP version of the server The header: a set of fields with key and value The body of the response response = http . send_request ( request ) puts \"Status: #{ response . status } \" puts \"HTTP version: #{ response . major_http_version } . #{ response . minor_http_version } \" puts \"Content-Type header: \" + response . get_field ( \"Content-Type\" ) puts \"Body: \\n \" + response . body The status code can be used to check whether the request was successfully processed or not: codes 2xx represent success, codes 3xx represent a redirection, codes 4xx represent client errors, codes 5xx represent server errors, and codes 10xx represent SFML specific errors which are not part of the HTTP standard.","title":"Responses"},{"location":"network/http.html#example-sending-scores-to-an-online-server","text":"Here is a short example that demonstrates how to perform a simple task: Sending a score to an online database. def send_score ( score , name ) # prepare the request request = SF :: Http :: Request . new ( \"/send-score.html\" , SF :: Http :: Request :: Post ) # encode the parameters in the request body request . body = \"name=\" + name + \"&score=\" + score # send the request http = SF :: Http . new ( \"http://www.myserver.com/\" ) response = http . send_request ( request ) # check the status if response . status . ok? # check the contents of the response puts response . body else puts \"request failed\" end end Of course, this is a very simple way to handle online scores. There's no protection: Anybody could easily send a false score. A more robust approach would probably involve an extra parameter, like a hash code that ensures that the request was sent by the program. That is beyond the scope of this tutorial. And finally, here is a very simple example of what the PHP page on server might look like. <?php $name = $_POST [ 'name' ]; $score = $_POST [ 'score' ]; if ( write_to_database ( $name , $score )) { // this is not a PHP tutorial :) echo 'name and score added!' ; } else { echo 'failed to write name and score to database...' ; }","title":"Example: sending scores to an online server"},{"location":"network/packet.html","text":"Using packets Problems that need to be solved Exchanging data on a network is more tricky than it seems. The reason is that different machines, with different operating systems and processors, can be involved. Several problems arise if you want to exchange data reliably between these different machines. The first problem is the endianness. The endianness is the order in which a particular processor interprets the bytes of primitive types that occupy more than a single byte (integers and floating point numbers). There are two main families: \"big endian\" processors, which store the most significant byte first, and \"little endian\" processors, which store the least significant byte first. There are other, more exotic byte orders, but you'll probably never have to deal with them. The problem is obvious: If you send a variable between two computers whose endianness doesn't match, they won't see the same value. For example, the 16-bit integer \"42\" in big endian notation is 00000000 00101010, but if you send this to a little endian machine, it will be interpreted as \"10752\". The second problem is specific to how the TCP protocol works. Because it doesn't preserve message boundaries, and can split or combine chunks of data, receivers must properly reconstruct incoming messages before interpreting them. Otherwise bad things might happen, like reading incomplete variables, or ignoring useful bytes. You may of course face other problems with network programming, but these are the lowest-level ones, that almost everybody will have to solve. This is the reason why SFML provides some simple tools to avoid them. Packets The two problems (endianness and message boundaries) are solved by using a specific class to pack your data: Packet . As a bonus, it provides a much nicer interface than plain old byte arrays. # on sending side x = 10_u16 s = \"hello\" d = 0.6_f64 packet = SF :: Packet . new () packet . write ( x ) packet . write ( s ) packet . write ( d ) # on receiving side x = packet . read ( UInt16 ) s = packet . read ( String ) d = packet . read ( Float64 ) pp x , s , d Unlike writing, reading from a packet can fail if you try to extract more bytes than the packet contains. If a reading operation fails, the packet error flag is set. To check the error flag of a packet, use the valid? method: x = packet . read ( Int32 ) unless packet . valid? # error end Sending and receiving packets is as easy as sending/receiving an array of bytes: sockets have send and receive methods that directly accept a Packet . # with a TCP socket status = tcp_socket . send ( packet ) packet = SF :: Packet . new status = tcp_socket . receive ( packet ) # with a UDP socket status = udp_socket . send ( packet , recipient_address , recipient_port ) packet = SF :: Packet . new status , sender_address , sender_port = udp_socket . receive ( packet ) Packets solve the \"message boundaries\" problem, which means that when you send a packet on a TCP socket, you receive the exact same packet on the other end, it cannot contain less bytes, or bytes from the next packet that you send. However, it has a slight drawback: To preserve message boundaries, Packet has to send some extra bytes along with your data, which implies that you can only receive them with a Packet if you want them to be properly decoded. Simply put, you can't send an SFML packet to a non-SFML packet recipient, it has to use an SFML packet for receiving too. Note that this applies to TCP only, UDP is fine since the protocol itself preserves message boundaries. Extending packets to handle user types Packets have overloads of their methods for the most common primitive types and the most common standard types, but what about your own classes? It is easy to subclass or reopen Packet and add your own overloads. record Character , age : UInt8 , name : String , weight : Float32 class SF:: Packet def write ( c : Character ) write c . age write c . name write c . weight end def read ( type : Character . class ) : Character Character . new ( read ( UInt8 ), read ( String ), read ( Float32 )) end end Now that these methods are defined, you can insert/extract a Character instance to/from a packet like any other primitive type: bob = Character . new ( 65_u8 , \"Bob\" , 12.34_f32 ) packet . write ( bob ) packet . read ( Character )","title":"Using packets"},{"location":"network/packet.html#using-packets","text":"","title":"Using packets"},{"location":"network/packet.html#problems-that-need-to-be-solved","text":"Exchanging data on a network is more tricky than it seems. The reason is that different machines, with different operating systems and processors, can be involved. Several problems arise if you want to exchange data reliably between these different machines. The first problem is the endianness. The endianness is the order in which a particular processor interprets the bytes of primitive types that occupy more than a single byte (integers and floating point numbers). There are two main families: \"big endian\" processors, which store the most significant byte first, and \"little endian\" processors, which store the least significant byte first. There are other, more exotic byte orders, but you'll probably never have to deal with them. The problem is obvious: If you send a variable between two computers whose endianness doesn't match, they won't see the same value. For example, the 16-bit integer \"42\" in big endian notation is 00000000 00101010, but if you send this to a little endian machine, it will be interpreted as \"10752\". The second problem is specific to how the TCP protocol works. Because it doesn't preserve message boundaries, and can split or combine chunks of data, receivers must properly reconstruct incoming messages before interpreting them. Otherwise bad things might happen, like reading incomplete variables, or ignoring useful bytes. You may of course face other problems with network programming, but these are the lowest-level ones, that almost everybody will have to solve. This is the reason why SFML provides some simple tools to avoid them.","title":"Problems that need to be solved"},{"location":"network/packet.html#packets","text":"The two problems (endianness and message boundaries) are solved by using a specific class to pack your data: Packet . As a bonus, it provides a much nicer interface than plain old byte arrays. # on sending side x = 10_u16 s = \"hello\" d = 0.6_f64 packet = SF :: Packet . new () packet . write ( x ) packet . write ( s ) packet . write ( d ) # on receiving side x = packet . read ( UInt16 ) s = packet . read ( String ) d = packet . read ( Float64 ) pp x , s , d Unlike writing, reading from a packet can fail if you try to extract more bytes than the packet contains. If a reading operation fails, the packet error flag is set. To check the error flag of a packet, use the valid? method: x = packet . read ( Int32 ) unless packet . valid? # error end Sending and receiving packets is as easy as sending/receiving an array of bytes: sockets have send and receive methods that directly accept a Packet . # with a TCP socket status = tcp_socket . send ( packet ) packet = SF :: Packet . new status = tcp_socket . receive ( packet ) # with a UDP socket status = udp_socket . send ( packet , recipient_address , recipient_port ) packet = SF :: Packet . new status , sender_address , sender_port = udp_socket . receive ( packet ) Packets solve the \"message boundaries\" problem, which means that when you send a packet on a TCP socket, you receive the exact same packet on the other end, it cannot contain less bytes, or bytes from the next packet that you send. However, it has a slight drawback: To preserve message boundaries, Packet has to send some extra bytes along with your data, which implies that you can only receive them with a Packet if you want them to be properly decoded. Simply put, you can't send an SFML packet to a non-SFML packet recipient, it has to use an SFML packet for receiving too. Note that this applies to TCP only, UDP is fine since the protocol itself preserves message boundaries.","title":"Packets"},{"location":"network/packet.html#extending-packets-to-handle-user-types","text":"Packets have overloads of their methods for the most common primitive types and the most common standard types, but what about your own classes? It is easy to subclass or reopen Packet and add your own overloads. record Character , age : UInt8 , name : String , weight : Float32 class SF:: Packet def write ( c : Character ) write c . age write c . name write c . weight end def read ( type : Character . class ) : Character Character . new ( read ( UInt8 ), read ( String ), read ( Float32 )) end end Now that these methods are defined, you can insert/extract a Character instance to/from a packet like any other primitive type: bob = Character . new ( 65_u8 , \"Bob\" , 12.34_f32 ) packet . write ( bob ) packet . read ( Character )","title":"Extending packets to handle user types"},{"location":"network/socket.html","text":"Communicating with sockets Sockets A socket is the interface between your application and the outside world: through a socket, you can send and receive data. Therefore, any network program will most likely have to deal with sockets, they are the central element of network communication. There are several kinds of sockets, each providing specific features. SFML implements the most common ones: TCP sockets and UDP sockets. TCP vs UDP It is important to know what TCP and UDP sockets can do, and what they can't do, so that you can choose the best socket type according to the requirements of your application. The main difference is that TCP sockets are connection-based. You can't send or receive anything until you are connected to another TCP socket on the remote machine. Once connected, a TCP socket can only send and receive to/from the remote machine. This means that you'll need one TCP socket for each client in your application. UDP is not connection-based, you can send and receive to/from anyone at any time with the same socket. The second difference is that TCP is reliable unlike UDP. It ensures that what you send is always received, without corruption and in the same order. UDP performs less checks, and doesn't provide any reliability: what you send might be received multiple times (duplication), or in a different order, or be lost and never reach the remote computer. However, UDP does guarantee that data which is received is always valid (not corrupted). UDP may seem scary, but keep in mind that almost all the time , data arrives correctly and in the right order. The third difference is a direct consequence of the second one: UDP is faster and more lightweight than TCP. Because it has less requirements, thus less overhead. The last difference is about the way data is transported. TCP is a stream protocol: there's no message boundary, if you send \"Hello\" and then \"SFML\", the remote machine might receive \"HelloSFML\", \"Hel\" + \"loSFML\", or even \"He\" + \"loS\" + \"FML\". UDP is a datagram protocol. Datagrams are packets that can't be mixed with each other. If you receive a datagram with UDP, it is guaranteed to be exactly the same as it was sent. Oh, and one last thing: since UDP is not connection-based, it allows broadcasting messages to multiple recipients, or even to an entire network. The one-to-one communication of TCP sockets doesn't allow that. Connecting a TCP socket As you can guess, this part is specific to TCP sockets. There are two sides to a connection: the one that waits for the incoming connection (let's call it the server), and the one that triggers it (let's call it the client). On client side, things are simple: the user just needs to have a TcpSocket and call its connect method to start the connection attempt. require \"crsfml/network\" socket = SF :: TcpSocket . new status = socket . connect ( SF :: IpAddress . new ( \"192.168.0.5\" ), 53000 ) unless status == SF :: Socket :: Done # error end The first argument is the address of the host to connect to. It is an IpAddress , which can represent any valid address: a URL, an IP address, or a network host name. See its documentation for more details. The second argument is the port to connect to on the remote machine. The connection will succeed only if the server is accepting connections on that port. There's an optional third argument, a time out value. If set, and the connection attempt doesn't succeed before the time out is over, the method returns an error. If not specified, the default operating system time out is used. Once connected, you can retrieve the address and port of the remote computer if needed, with the remote_address and remote_port methods. All methods of socket classes are blocking by default. This means that your program (more specifically the thread that contains the method call) will be stuck until the operation is complete. This is important because some methods may take very long: For example, trying to connect to an unreachable host will only return after a few seconds, receiving will wait until there's data available, etc. You can change this behavior and make all methods non-blocking by using the blocking= method of the socket. See the next chapters for more details. On the server side, a few more things have to be done. Multiple sockets are required: One that listens for incoming connections, and one for each connected client. To listen for connections, you must use the special TcpListener class. Its only role is to wait for incoming connection attempts on a given port, it can't send or receive data. listener = SF :: TcpListener . new # bind the listener to a port unless listener . listen ( 53000 ) == SF :: Socket :: Done # error... end # accept a new connection client = SF :: TcpSocket . new unless listener . accept ( client ) == SF :: Socket :: Done # error... end # use \"client\" to communicate with the connected client, # and continue to accept new connections with the listener The accept method blocks until a connection attempt arrives (unless the socket is configured as non-blocking). When it happens, it initializes the given socket and returns. The socket can now be used to communicate with the new client, and the listener can go back to waiting for another connection attempt. After a successful call to connect (on client side) and accept (on server side), the communication is established and both sockets are ready to exchange data. Binding a UDP socket UDP sockets need not be connected, however you need to bind them to a specific port if you want to be able to receive data on that port. A UDP socket cannot receive on multiple ports simultaneously. socket = SF :: UdpSocket . new # bind the socket to a port unless socket . bind ( 54000 ) == SF :: Socket :: Done # error... end After binding the socket to a port, it's ready to receive data on that port. If you want the operating system to bind the socket to a free port automatically, you can pass SF::Socket::AnyPort , and then retrieve the chosen port with socket.local_port . UDP sockets that send data don't need to do anything before sending. Sending and receiving data Sending and receiving data is done in the same way for both types of sockets. The only difference is that UDP has two extra arguments: the address and port of the sender/recipient. There are two different methods for each operation: the low-level one, that sends/receives a raw array of bytes, and the higher-level one, which uses the Packet class. See the tutorial on packets for more details about this class. In this tutorial, we'll only explain the low-level methods. To send data, you must call the send method with a pointer to the data that you want to send, and the number of bytes to send. data = Slice . new ( 77 ) { rand ( 256 ) . to_u8 } # TCP socket: unless socket . send ( data ) == SF :: Socket :: Done # error end # UDP socket: recipient = SF :: IpAddress . new ( \"192.168.0.5\" ) port = 54000 unless socket . send ( data , recipient , port ) == SF :: Socket :: Done # error end The send methods take a data slice, so you can pass the address of anything. However, it is generally a bad idea to send something other than an array of bytes because native types with a size larger than 1 byte are not guaranteed to be the same on every machine: Types such as int or long may have a different size, and/or a different endianness. Therefore, such types cannot be exchanged reliably across different systems. This problem is explained (and solved) in the tutorial on packets . With UDP you can broadcast a message to an entire sub-network in a single call: to do so you can use the special address SF::IpAddress::Broadcast . There's another thing to keep in mind with UDP: Since data is sent in datagrams and the size of these datagrams has a limit, you are not allowed to exceed it. Every call to send must send less that SF::UdpSocket.max_datagram_size bytes -- which is a little less than 2^16 (65536) bytes. To receive data, you must call the receive method: data = Slice ( UInt8 ) . new ( 100 ) # TCP socket: status , received = socket . receive ( data ) unless status == SF :: Socket :: Done # error end puts \"Received #{ received } bytes\" # UDP socket: status , received , sender , port = socket . receive ( data ) unless status == SF :: Socket :: Done # error... end puts \"Received #{ received } bytes from #{ sender } on port #{ port } \" It is important to keep in mind that if the socket is in blocking mode, receive will wait until something is received, blocking the thread that called it (and thus possibly the whole program). The first two arguments specify the buffer to which the received bytes are to be copied, along with its maximum size. The third argument is a variable that will contain the actual number of bytes received after the method returns. With UDP sockets, the last two arguments will contain the address and port of the sender after the method returns. They can be used later if you want to send a response. These methods are low-level, and you should use them only if you have a very good reason to do so. A more robust and flexible approach involves using packets . Blocking on a group of sockets Blocking on a single socket can quickly become annoying, because you will most likely have to handle more than one client. You most likely don't want socket A to block your program while socket B has received something that could be processed. What you would like is to block on multiple sockets at once, i.e. waiting until any of them has received something. This is possible with socket selectors, represented by the SocketSelector class. A selector can monitor all types of sockets: TcpSocket , UdpSocket , and TcpListener . To add a socket to a selector, use its add method: socket = SF :: TcpSocket . new selector = SF :: SocketSelector . new selector . add socket A selector is not a socket container. It only references (points to) the sockets that you add, it doesn't store them. There is no way to retrieve or count the sockets that you put inside. Instead, it is up to you to have your own separate socket storage (like an Array ). Once you have filled the selector with all the sockets that you want to monitor, you must call its wait method to wait until any one of them has received something (or has triggered an error). You can also pass an optional time out value, so that the method will fail if nothing has been received after a certain period of time -- this avoids staying stuck forever if nothing happens. if selector . wait SF . seconds ( 10 ) # received something else # timeout reached, nothing was received... end If the wait method returns true , it means that one or more socket(s) have received something, and you can safely call receive on the socket(s) with pending data without having them block. If the socket is a TcpListener , it means that an incoming connection is ready to be accepted and that you can call its accept method without having it block. Since the selector is not a socket container, it cannot return the sockets that are ready to receive. Instead, you must test each candidate socket with the ready? method: if selector . wait SF . seconds ( 10 ) my_sockets . each do | socket | if selector . ready? ( socket ) # this socket is ready, you can receive (or accept if it's a listener) socket . receive ( ... ) end end end You can have a look at the API documentation of the SocketSelector class for a working example of how to use a selector to handle connections and messages from multiple clients. As a bonus, the timeout capability of Selector#wait allows you to implement a receive-with-timeout method, which is not directly available in the socket classes, very easily: def receive_with_timeout ( socket : SF :: TcpSocket , packet : SF :: Packet , timeout : SF :: Time ) selector = SF :: SocketSelector . new selector . add socket if selector . wait ( timeout ) socket . receive ( packet ) else SF :: Socket :: NotReady end end Non-blocking sockets All sockets are blocking by default, but you can change this behaviour at any time with the setBlocking method. tcp_socket = SF :: TcpSocket . new tcp_socket . blocking = false listener_socket = SF :: TcpListener . new listener_socket . blocking = false udp_socket = SF :: UdpSocket . new udp_socket . blocking = false Once a socket is set as non-blocking, all of its methods always return immediately. For example, receive will return with status SF::Socket::NotReady if there's no data available. Or, accept will return immediately, with the same status, if there's no pending connection. Non-blocking sockets are the easiest solution if you already have a main loop that runs at a constant rate. You can simply check if something happened on your sockets in every iteration, without having to block program execution. When using SF::TcpSocket in non-blocking mode, calls to send are not guaranteed to actually send all the data you pass to it, whether it be as a SF::Packet or as raw data. Make sure to check one of the return values for how much data was actually sent. Regardless of whether you send SF::Packet s or raw data, if only a part of the data was sent in the call, the return status will be SF::Socket::Partial to indicate a partial send. If SF::Socket::Partial is returned, you must make sure to handle the partial send properly or else data corruption will occur. When sending raw data, you must reattempt sending the raw data at the byte offset where the previous send call stopped. When sending SF::Packet s, the byte offset is saved within the SF::Packet itself. In this case, you must make sure to keep attempting to send the exact same unmodified SF::Packet object over and over until a status other than SF::Socket::Partial is returned. Constructing a new SF::Packet object and filling it with the same data will not work, it must be the same object that was previously sent.","title":"Communication using sockets"},{"location":"network/socket.html#communicating-with-sockets","text":"","title":"Communicating with sockets"},{"location":"network/socket.html#sockets","text":"A socket is the interface between your application and the outside world: through a socket, you can send and receive data. Therefore, any network program will most likely have to deal with sockets, they are the central element of network communication. There are several kinds of sockets, each providing specific features. SFML implements the most common ones: TCP sockets and UDP sockets.","title":"Sockets"},{"location":"network/socket.html#tcp-vs-udp","text":"It is important to know what TCP and UDP sockets can do, and what they can't do, so that you can choose the best socket type according to the requirements of your application. The main difference is that TCP sockets are connection-based. You can't send or receive anything until you are connected to another TCP socket on the remote machine. Once connected, a TCP socket can only send and receive to/from the remote machine. This means that you'll need one TCP socket for each client in your application. UDP is not connection-based, you can send and receive to/from anyone at any time with the same socket. The second difference is that TCP is reliable unlike UDP. It ensures that what you send is always received, without corruption and in the same order. UDP performs less checks, and doesn't provide any reliability: what you send might be received multiple times (duplication), or in a different order, or be lost and never reach the remote computer. However, UDP does guarantee that data which is received is always valid (not corrupted). UDP may seem scary, but keep in mind that almost all the time , data arrives correctly and in the right order. The third difference is a direct consequence of the second one: UDP is faster and more lightweight than TCP. Because it has less requirements, thus less overhead. The last difference is about the way data is transported. TCP is a stream protocol: there's no message boundary, if you send \"Hello\" and then \"SFML\", the remote machine might receive \"HelloSFML\", \"Hel\" + \"loSFML\", or even \"He\" + \"loS\" + \"FML\". UDP is a datagram protocol. Datagrams are packets that can't be mixed with each other. If you receive a datagram with UDP, it is guaranteed to be exactly the same as it was sent. Oh, and one last thing: since UDP is not connection-based, it allows broadcasting messages to multiple recipients, or even to an entire network. The one-to-one communication of TCP sockets doesn't allow that.","title":"TCP vs UDP"},{"location":"network/socket.html#connecting-a-tcp-socket","text":"As you can guess, this part is specific to TCP sockets. There are two sides to a connection: the one that waits for the incoming connection (let's call it the server), and the one that triggers it (let's call it the client). On client side, things are simple: the user just needs to have a TcpSocket and call its connect method to start the connection attempt. require \"crsfml/network\" socket = SF :: TcpSocket . new status = socket . connect ( SF :: IpAddress . new ( \"192.168.0.5\" ), 53000 ) unless status == SF :: Socket :: Done # error end The first argument is the address of the host to connect to. It is an IpAddress , which can represent any valid address: a URL, an IP address, or a network host name. See its documentation for more details. The second argument is the port to connect to on the remote machine. The connection will succeed only if the server is accepting connections on that port. There's an optional third argument, a time out value. If set, and the connection attempt doesn't succeed before the time out is over, the method returns an error. If not specified, the default operating system time out is used. Once connected, you can retrieve the address and port of the remote computer if needed, with the remote_address and remote_port methods. All methods of socket classes are blocking by default. This means that your program (more specifically the thread that contains the method call) will be stuck until the operation is complete. This is important because some methods may take very long: For example, trying to connect to an unreachable host will only return after a few seconds, receiving will wait until there's data available, etc. You can change this behavior and make all methods non-blocking by using the blocking= method of the socket. See the next chapters for more details. On the server side, a few more things have to be done. Multiple sockets are required: One that listens for incoming connections, and one for each connected client. To listen for connections, you must use the special TcpListener class. Its only role is to wait for incoming connection attempts on a given port, it can't send or receive data. listener = SF :: TcpListener . new # bind the listener to a port unless listener . listen ( 53000 ) == SF :: Socket :: Done # error... end # accept a new connection client = SF :: TcpSocket . new unless listener . accept ( client ) == SF :: Socket :: Done # error... end # use \"client\" to communicate with the connected client, # and continue to accept new connections with the listener The accept method blocks until a connection attempt arrives (unless the socket is configured as non-blocking). When it happens, it initializes the given socket and returns. The socket can now be used to communicate with the new client, and the listener can go back to waiting for another connection attempt. After a successful call to connect (on client side) and accept (on server side), the communication is established and both sockets are ready to exchange data.","title":"Connecting a TCP socket"},{"location":"network/socket.html#binding-a-udp-socket","text":"UDP sockets need not be connected, however you need to bind them to a specific port if you want to be able to receive data on that port. A UDP socket cannot receive on multiple ports simultaneously. socket = SF :: UdpSocket . new # bind the socket to a port unless socket . bind ( 54000 ) == SF :: Socket :: Done # error... end After binding the socket to a port, it's ready to receive data on that port. If you want the operating system to bind the socket to a free port automatically, you can pass SF::Socket::AnyPort , and then retrieve the chosen port with socket.local_port . UDP sockets that send data don't need to do anything before sending.","title":"Binding a UDP socket"},{"location":"network/socket.html#sending-and-receiving-data","text":"Sending and receiving data is done in the same way for both types of sockets. The only difference is that UDP has two extra arguments: the address and port of the sender/recipient. There are two different methods for each operation: the low-level one, that sends/receives a raw array of bytes, and the higher-level one, which uses the Packet class. See the tutorial on packets for more details about this class. In this tutorial, we'll only explain the low-level methods. To send data, you must call the send method with a pointer to the data that you want to send, and the number of bytes to send. data = Slice . new ( 77 ) { rand ( 256 ) . to_u8 } # TCP socket: unless socket . send ( data ) == SF :: Socket :: Done # error end # UDP socket: recipient = SF :: IpAddress . new ( \"192.168.0.5\" ) port = 54000 unless socket . send ( data , recipient , port ) == SF :: Socket :: Done # error end The send methods take a data slice, so you can pass the address of anything. However, it is generally a bad idea to send something other than an array of bytes because native types with a size larger than 1 byte are not guaranteed to be the same on every machine: Types such as int or long may have a different size, and/or a different endianness. Therefore, such types cannot be exchanged reliably across different systems. This problem is explained (and solved) in the tutorial on packets . With UDP you can broadcast a message to an entire sub-network in a single call: to do so you can use the special address SF::IpAddress::Broadcast . There's another thing to keep in mind with UDP: Since data is sent in datagrams and the size of these datagrams has a limit, you are not allowed to exceed it. Every call to send must send less that SF::UdpSocket.max_datagram_size bytes -- which is a little less than 2^16 (65536) bytes. To receive data, you must call the receive method: data = Slice ( UInt8 ) . new ( 100 ) # TCP socket: status , received = socket . receive ( data ) unless status == SF :: Socket :: Done # error end puts \"Received #{ received } bytes\" # UDP socket: status , received , sender , port = socket . receive ( data ) unless status == SF :: Socket :: Done # error... end puts \"Received #{ received } bytes from #{ sender } on port #{ port } \" It is important to keep in mind that if the socket is in blocking mode, receive will wait until something is received, blocking the thread that called it (and thus possibly the whole program). The first two arguments specify the buffer to which the received bytes are to be copied, along with its maximum size. The third argument is a variable that will contain the actual number of bytes received after the method returns. With UDP sockets, the last two arguments will contain the address and port of the sender after the method returns. They can be used later if you want to send a response. These methods are low-level, and you should use them only if you have a very good reason to do so. A more robust and flexible approach involves using packets .","title":"Sending and receiving data"},{"location":"network/socket.html#blocking-on-a-group-of-sockets","text":"Blocking on a single socket can quickly become annoying, because you will most likely have to handle more than one client. You most likely don't want socket A to block your program while socket B has received something that could be processed. What you would like is to block on multiple sockets at once, i.e. waiting until any of them has received something. This is possible with socket selectors, represented by the SocketSelector class. A selector can monitor all types of sockets: TcpSocket , UdpSocket , and TcpListener . To add a socket to a selector, use its add method: socket = SF :: TcpSocket . new selector = SF :: SocketSelector . new selector . add socket A selector is not a socket container. It only references (points to) the sockets that you add, it doesn't store them. There is no way to retrieve or count the sockets that you put inside. Instead, it is up to you to have your own separate socket storage (like an Array ). Once you have filled the selector with all the sockets that you want to monitor, you must call its wait method to wait until any one of them has received something (or has triggered an error). You can also pass an optional time out value, so that the method will fail if nothing has been received after a certain period of time -- this avoids staying stuck forever if nothing happens. if selector . wait SF . seconds ( 10 ) # received something else # timeout reached, nothing was received... end If the wait method returns true , it means that one or more socket(s) have received something, and you can safely call receive on the socket(s) with pending data without having them block. If the socket is a TcpListener , it means that an incoming connection is ready to be accepted and that you can call its accept method without having it block. Since the selector is not a socket container, it cannot return the sockets that are ready to receive. Instead, you must test each candidate socket with the ready? method: if selector . wait SF . seconds ( 10 ) my_sockets . each do | socket | if selector . ready? ( socket ) # this socket is ready, you can receive (or accept if it's a listener) socket . receive ( ... ) end end end You can have a look at the API documentation of the SocketSelector class for a working example of how to use a selector to handle connections and messages from multiple clients. As a bonus, the timeout capability of Selector#wait allows you to implement a receive-with-timeout method, which is not directly available in the socket classes, very easily: def receive_with_timeout ( socket : SF :: TcpSocket , packet : SF :: Packet , timeout : SF :: Time ) selector = SF :: SocketSelector . new selector . add socket if selector . wait ( timeout ) socket . receive ( packet ) else SF :: Socket :: NotReady end end","title":"Blocking on a group of sockets"},{"location":"network/socket.html#non-blocking-sockets","text":"All sockets are blocking by default, but you can change this behaviour at any time with the setBlocking method. tcp_socket = SF :: TcpSocket . new tcp_socket . blocking = false listener_socket = SF :: TcpListener . new listener_socket . blocking = false udp_socket = SF :: UdpSocket . new udp_socket . blocking = false Once a socket is set as non-blocking, all of its methods always return immediately. For example, receive will return with status SF::Socket::NotReady if there's no data available. Or, accept will return immediately, with the same status, if there's no pending connection. Non-blocking sockets are the easiest solution if you already have a main loop that runs at a constant rate. You can simply check if something happened on your sockets in every iteration, without having to block program execution. When using SF::TcpSocket in non-blocking mode, calls to send are not guaranteed to actually send all the data you pass to it, whether it be as a SF::Packet or as raw data. Make sure to check one of the return values for how much data was actually sent. Regardless of whether you send SF::Packet s or raw data, if only a part of the data was sent in the call, the return status will be SF::Socket::Partial to indicate a partial send. If SF::Socket::Partial is returned, you must make sure to handle the partial send properly or else data corruption will occur. When sending raw data, you must reattempt sending the raw data at the byte offset where the previous send call stopped. When sending SF::Packet s, the byte offset is saved within the SF::Packet itself. In this case, you must make sure to keep attempting to send the exact same unmodified SF::Packet object over and over until a status other than SF::Socket::Partial is returned. Constructing a new SF::Packet object and filling it with the same data will not work, it must be the same object that was previously sent.","title":"Non-blocking sockets"},{"location":"system/stream.html","text":"User data streams Introduction SFML has several resource classes: images, fonts, sounds, etc. In most programs, these resources will be loaded from files, with the help of their from_file class method. In a few other situations, resources will be packed directly into the executable or in a big data file, and loaded from memory with from_memory . These methods cover almost all the possible use cases -- but not all. Sometimes you want to load files from unusual places, such as a compressed/encrypted archive, or a remote network location for example. For these special situations, CrSFML provides a third loading method: from_stream . This method reads data using an abstract InputStream interface, which allows you to provide your own implementation of a stream class that works with SFML. In this tutorial you'll learn how to write and use your own derived input stream. InputStream The InputStream class declares four virtual methods: abstract class InputStream abstract def read ( data : Slice ) : Int64 abstract def seek ( position : Int ) : Int64 abstract def tell () : Int64 abstract def size () : Int64 end read must extract buffer.size bytes of data from the stream, and copy them to the supplied buffer slice. It returns the number of bytes read, or -1 on error. seek must change the current reading position in the stream. Its position argument is the absolute byte offset to jump to (so it is relative to the beginning of the data, not to the current position). It returns the new position, or -1 on error. tell must return the current reading position (in bytes) in the stream, or -1 on error. size must return the total size (in bytes) of the data which is contained in the stream, or -1 on error. To create your own working stream, you must implement every one of these four methods according to their requirements. FileInputStream and MemoryInputStream SF::FileInputStream provides the read-only data stream of a file, while SF::MemoryInputStream serves the read-only stream from memory. Both are derived from SF::InputStream . Using an InputStream Using a custom stream class is straight-forward: instantiate it, and pass it to the from_stream class method of the object that you want to load. stream = SF :: FileInputStream . open ( \"image.png\" ) texture = SF :: Texture . from_stream ( stream ) stream = SF :: FileInputStream . open ( \"music.ogg\" ) music = SF :: Music . from_stream ( stream ) string = File . read ( \"image.png\" ) stream = SF :: MemoryInputStream . open ( string . to_slice ) texture = SF :: Texture . from_stream ( stream ) Note that the examples above are redundant, because from_file can be used instead. The real use cases are if you want to implement custom loading of resources. Option 1: read from file, extract into memory, use MemoryInputStream . Option 2: implement a custom stream that reads and extracts on the fly. Examples If you need a demonstration that helps you focus on how the code works, and not get lost in implementation details, you could take a look at the implementation of FileInputStream or MemoryInputStream . Common mistakes Some resource classes are not loaded completely after from_stream has been called. Instead, they continue to read from their data source as long as they are used. This is the case for Music , which streams audio samples as they are played, and for Font , which loads glyphs on the fly depending on the text that is displayed. As a consequence, the stream instance that you used to load a music or a font, as well as its data source, must remain alive as long as the resource uses it. If it is destroyed while still being used, it results in undefined behavior (can be a crash, corrupt data, or nothing visible). Another common mistake is to return whatever the internal functions return directly, but sometimes it doesn't match what SFML expects. For example, some function may return 0 on success, but InputStream#seek expects the actual new position to be returned. Also keep in mind that in case of error -1 must be returned.","title":"User data streams"},{"location":"system/stream.html#user-data-streams","text":"","title":"User data streams"},{"location":"system/stream.html#introduction","text":"SFML has several resource classes: images, fonts, sounds, etc. In most programs, these resources will be loaded from files, with the help of their from_file class method. In a few other situations, resources will be packed directly into the executable or in a big data file, and loaded from memory with from_memory . These methods cover almost all the possible use cases -- but not all. Sometimes you want to load files from unusual places, such as a compressed/encrypted archive, or a remote network location for example. For these special situations, CrSFML provides a third loading method: from_stream . This method reads data using an abstract InputStream interface, which allows you to provide your own implementation of a stream class that works with SFML. In this tutorial you'll learn how to write and use your own derived input stream.","title":"Introduction"},{"location":"system/stream.html#inputstream","text":"The InputStream class declares four virtual methods: abstract class InputStream abstract def read ( data : Slice ) : Int64 abstract def seek ( position : Int ) : Int64 abstract def tell () : Int64 abstract def size () : Int64 end read must extract buffer.size bytes of data from the stream, and copy them to the supplied buffer slice. It returns the number of bytes read, or -1 on error. seek must change the current reading position in the stream. Its position argument is the absolute byte offset to jump to (so it is relative to the beginning of the data, not to the current position). It returns the new position, or -1 on error. tell must return the current reading position (in bytes) in the stream, or -1 on error. size must return the total size (in bytes) of the data which is contained in the stream, or -1 on error. To create your own working stream, you must implement every one of these four methods according to their requirements.","title":"InputStream"},{"location":"system/stream.html#fileinputstream-and-memoryinputstream","text":"SF::FileInputStream provides the read-only data stream of a file, while SF::MemoryInputStream serves the read-only stream from memory. Both are derived from SF::InputStream .","title":"FileInputStream and MemoryInputStream"},{"location":"system/stream.html#using-an-inputstream","text":"Using a custom stream class is straight-forward: instantiate it, and pass it to the from_stream class method of the object that you want to load. stream = SF :: FileInputStream . open ( \"image.png\" ) texture = SF :: Texture . from_stream ( stream ) stream = SF :: FileInputStream . open ( \"music.ogg\" ) music = SF :: Music . from_stream ( stream ) string = File . read ( \"image.png\" ) stream = SF :: MemoryInputStream . open ( string . to_slice ) texture = SF :: Texture . from_stream ( stream ) Note that the examples above are redundant, because from_file can be used instead. The real use cases are if you want to implement custom loading of resources. Option 1: read from file, extract into memory, use MemoryInputStream . Option 2: implement a custom stream that reads and extracts on the fly.","title":"Using an InputStream"},{"location":"system/stream.html#examples","text":"If you need a demonstration that helps you focus on how the code works, and not get lost in implementation details, you could take a look at the implementation of FileInputStream or MemoryInputStream .","title":"Examples"},{"location":"system/stream.html#common-mistakes","text":"Some resource classes are not loaded completely after from_stream has been called. Instead, they continue to read from their data source as long as they are used. This is the case for Music , which streams audio samples as they are played, and for Font , which loads glyphs on the fly depending on the text that is displayed. As a consequence, the stream instance that you used to load a music or a font, as well as its data source, must remain alive as long as the resource uses it. If it is destroyed while still being used, it results in undefined behavior (can be a crash, corrupt data, or nothing visible). Another common mistake is to return whatever the internal functions return directly, but sometimes it doesn't match what SFML expects. For example, some function may return 0 on success, but InputStream#seek expects the actual new position to be returned. Also keep in mind that in case of error -1 must be returned.","title":"Common mistakes"},{"location":"system/thread.html","text":"Threads What is a thread? Most of you should already know what a thread is, however here is a little explanation for those who are really new to this concept. A thread is basically a sequence of instructions that run in parallel to other threads. Every program is made of at least one thread: the main one, which runs the top level code in your program. Programs that only use the main thread are single-threaded , if you add one or more threads they become multi-threaded . So, in short, threads are a way to do multiple things at the same time. This can be useful, for example, to display an animation and reacting to user input while loading images or sounds. Threads are also widely used in network programming, to wait for data to be received while continuing to update and draw the application. SFML threads or alternatives? Multithreaded code is inherently unsafe. Crystal itself has a Thread class, but it is classified as internal, because better ways to do concurrency are being developed. Crystal's standard library is not intended to be used with raw threads. Garbage collection in additional threads causes crashes. Exceptions don't work either. Please make sure you know what you're doing before choosing SFML threads. Creating a thread with CrSFML Enough talk, let's see some code. The class that makes it possible to create threads in CrSFML is Thread , and here is what it looks like in action: require \"crsfml/system\" def func # this function is started when thread.launch() is called 7 . times do puts \"I'm thread number one\" SF . sleep SF . seconds ( 0.3 ) end end # create a thread with func() as entry point thread = SF :: Thread . new ( -> func ) # run it thread . launch () # the main thread continues to run... SF . sleep SF . seconds ( 0.15 ) 7 . times do puts \"I'm the main thread\" SF . sleep SF . seconds ( 0.3 ) end In this code, both main and func run in parallel after thread.launch() has been called. The result is that text from both functions should be mixed in the console: I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread The entry point of the thread, ie. the function that will be run when the thread is started, must be passed to the constructor of Thread . Thread can accept any kind of procs without parameters. Starting threads Once you've created a Thread instance, you must start it with the launch method. thread = SF :: Thread . new ( -> func ) thread . launch () launch calls the function that you passed to the constructor in a new thread, and returns immediately so that the calling thread can continue to run. Stopping threads A thread automatically stops when its entry point function returns. If you want to wait for a thread to finish from another thread, you can call its wait method. thread = SF :: Thread ( -> func ) # start the thread thread . launch () ... # block execution until the thread is finished thread . wait () The wait method is also implicitly called by the destructor of Thread , so that a thread cannot remain alive (and out of control) after its owner Thread instance is destroyed. Keep this in mind when you manage your threads (see the last section of this tutorial). Pausing threads There's no method in Thread that allows another thread to pause it, the only way to pause a thread is to do it from the code that it runs. In other words, you can only pause the current thread. To do so, you can call the SF.sleep function, as demonstrated in the first example. SF.sleep has one argument, which is the time to sleep. This duration can be given with any unit/precision, as seen in the time tutorial . Note that you can make any thread sleep with this function, even the main one. SF.sleep is the most efficient way to pause a thread: as long as the thread sleeps, it requires zero CPU. Pauses based on active waiting, like empty while loops, would consume 100% CPU just to do... nothing. However, keep in mind that the sleep duration is just a hint, depending on the OS it will be more or less accurate. So don't rely on it for very precise timing. Protecting shared data All the threads in a program share the same memory, they have access to all variables in the scope they are in. It is very convenient but also dangerous: since threads run in parallel, it means that a variable or function might be used concurrently from several threads at the same time. If the operation is not thread-safe , it can lead to undefined behavior (ie. it might crash or corrupt data). In the first example we had to make sure that the puts calls never happen at the same time, by applying appropriate timing. If the sleeps are gone, the program crashes. Crystal's standard library is not intended to be used with raw threads. Several programming tools exist to help you protect shared data and make your code thread-safe, these are called synchronization primitives. Common ones are mutexes, semaphores, condition variables and spin locks. They are all variants of the same concept: they protect a piece of code by allowing only certain threads to access it while blocking the others. The most basic (and used) primitive is the mutex. Mutex stands for \"MUTual EXclusion\": it ensures that only a single thread is able to run the code that it guards. Let's see how they can bring some order to the example above: require \"crsfml/system\" class Foo @mutex = SF :: Mutex . new def task @mutex . lock 7 . times { puts \"I'm thread number one\" } @mutex . unlock end def main thread = SF :: Thread . new ( -> task ) thread . launch @mutex . lock 7 . times { puts \"I'm the main thread\" } @mutex . unlock thread . wait # wait until function task has finished end end foo = Foo . new foo . main This code uses a shared resource (standard output). Inappropriate use of it causes the lines/letters to be randomly mixed or even crashes. To avoid this, we protect the corresponding region of the code with a mutex. The first thread that reaches its mutex.lock() line succeeds to lock the mutex, directly gains access to the code that follows and prints its text. When the other thread reaches its mutex.lock() line, the mutex is already locked and thus the thread is put to sleep (like SF.sleep , no CPU time is consumed by the sleeping thread). When the first thread finally unlocks the mutex, the second thread is awoken and is allowed to lock the mutex and print its text block as well. This leads to the lines of text appearing sequentially in the console instead of being mixed. I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one Mutexes are not the only primitive that you can use to protect your shared variables, but it should be enough for most cases. However, if your application does complicated things with threads, and you feel like it is not enough, don't hesitate to look for alternatives. Protecting mutexes Don't worry: mutexes are already thread-safe, there's no need to protect them. But what if there is a failure in the code and the mutex never gets a chance to be unlocked? It remains locked forever. All threads that try to lock it in the future will block forever, and in some cases, your whole application could freeze. Pretty bad result. To make sure that mutexes are always unlocked in an environment where exceptions can be thrown, CrSFML provides a special method that receives a block: synchronize . The mutex is locked before the block and is unlocked after the block (even if an exception is raised). Thus, we can write previous code example in a simpler way, using synchronize like this: require \"crsfml/system\" class Foo @mutex = SF :: Mutex . new def task @mutex . synchronize do # lock mutex implicitly 7 . times { puts \"I'm thread number one\" } end # unlock mutex implicitly end def main thread = SF :: Thread . new ( -> task ) thread . launch @mutex . synchronize do # same as above 7 . times { puts \"I'm the main thread\" } end thread . wait end end foo = Foo . new foo . main Common mistakes One thing that is often overlooked by programmers is that a thread cannot live without its corresponding Thread instance. The following code is often seen: def func SF . sleep ( SF . seconds ( 10 )) end def start_thread SF :: Thread . new ( -> func ) . launch end start_thread () # ... Programmers who write this kind of code expect the start_thread function to start a thread that will live on its own and be destroyed when the threaded function ends. This is not what happens. The threaded function appears to block the main thread, as if the thread wasn't working. What is the cause of this? The Thread instance is local to the start_thread() function and is therefore destroyed, when the function returns. The finalizer of Thread is invoked, which calls wait() as we've learned above, and the result is that the main thread blocks and waits for the threaded function to be finished instead of continuing to run in parallel. So don't forget: You must manage your Thread instance so that it lives as long as the threaded function is supposed to run.","title":"Threads"},{"location":"system/thread.html#threads","text":"","title":"Threads"},{"location":"system/thread.html#what-is-a-thread","text":"Most of you should already know what a thread is, however here is a little explanation for those who are really new to this concept. A thread is basically a sequence of instructions that run in parallel to other threads. Every program is made of at least one thread: the main one, which runs the top level code in your program. Programs that only use the main thread are single-threaded , if you add one or more threads they become multi-threaded . So, in short, threads are a way to do multiple things at the same time. This can be useful, for example, to display an animation and reacting to user input while loading images or sounds. Threads are also widely used in network programming, to wait for data to be received while continuing to update and draw the application.","title":"What is a thread?"},{"location":"system/thread.html#sfml-threads-or-alternatives","text":"Multithreaded code is inherently unsafe. Crystal itself has a Thread class, but it is classified as internal, because better ways to do concurrency are being developed. Crystal's standard library is not intended to be used with raw threads. Garbage collection in additional threads causes crashes. Exceptions don't work either. Please make sure you know what you're doing before choosing SFML threads.","title":"SFML threads or alternatives?"},{"location":"system/thread.html#creating-a-thread-with-crsfml","text":"Enough talk, let's see some code. The class that makes it possible to create threads in CrSFML is Thread , and here is what it looks like in action: require \"crsfml/system\" def func # this function is started when thread.launch() is called 7 . times do puts \"I'm thread number one\" SF . sleep SF . seconds ( 0.3 ) end end # create a thread with func() as entry point thread = SF :: Thread . new ( -> func ) # run it thread . launch () # the main thread continues to run... SF . sleep SF . seconds ( 0.15 ) 7 . times do puts \"I'm the main thread\" SF . sleep SF . seconds ( 0.3 ) end In this code, both main and func run in parallel after thread.launch() has been called. The result is that text from both functions should be mixed in the console: I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread The entry point of the thread, ie. the function that will be run when the thread is started, must be passed to the constructor of Thread . Thread can accept any kind of procs without parameters.","title":"Creating a thread with CrSFML"},{"location":"system/thread.html#starting-threads","text":"Once you've created a Thread instance, you must start it with the launch method. thread = SF :: Thread . new ( -> func ) thread . launch () launch calls the function that you passed to the constructor in a new thread, and returns immediately so that the calling thread can continue to run.","title":"Starting threads"},{"location":"system/thread.html#stopping-threads","text":"A thread automatically stops when its entry point function returns. If you want to wait for a thread to finish from another thread, you can call its wait method. thread = SF :: Thread ( -> func ) # start the thread thread . launch () ... # block execution until the thread is finished thread . wait () The wait method is also implicitly called by the destructor of Thread , so that a thread cannot remain alive (and out of control) after its owner Thread instance is destroyed. Keep this in mind when you manage your threads (see the last section of this tutorial).","title":"Stopping threads"},{"location":"system/thread.html#pausing-threads","text":"There's no method in Thread that allows another thread to pause it, the only way to pause a thread is to do it from the code that it runs. In other words, you can only pause the current thread. To do so, you can call the SF.sleep function, as demonstrated in the first example. SF.sleep has one argument, which is the time to sleep. This duration can be given with any unit/precision, as seen in the time tutorial . Note that you can make any thread sleep with this function, even the main one. SF.sleep is the most efficient way to pause a thread: as long as the thread sleeps, it requires zero CPU. Pauses based on active waiting, like empty while loops, would consume 100% CPU just to do... nothing. However, keep in mind that the sleep duration is just a hint, depending on the OS it will be more or less accurate. So don't rely on it for very precise timing.","title":"Pausing threads"},{"location":"system/thread.html#protecting-shared-data","text":"All the threads in a program share the same memory, they have access to all variables in the scope they are in. It is very convenient but also dangerous: since threads run in parallel, it means that a variable or function might be used concurrently from several threads at the same time. If the operation is not thread-safe , it can lead to undefined behavior (ie. it might crash or corrupt data). In the first example we had to make sure that the puts calls never happen at the same time, by applying appropriate timing. If the sleeps are gone, the program crashes. Crystal's standard library is not intended to be used with raw threads. Several programming tools exist to help you protect shared data and make your code thread-safe, these are called synchronization primitives. Common ones are mutexes, semaphores, condition variables and spin locks. They are all variants of the same concept: they protect a piece of code by allowing only certain threads to access it while blocking the others. The most basic (and used) primitive is the mutex. Mutex stands for \"MUTual EXclusion\": it ensures that only a single thread is able to run the code that it guards. Let's see how they can bring some order to the example above: require \"crsfml/system\" class Foo @mutex = SF :: Mutex . new def task @mutex . lock 7 . times { puts \"I'm thread number one\" } @mutex . unlock end def main thread = SF :: Thread . new ( -> task ) thread . launch @mutex . lock 7 . times { puts \"I'm the main thread\" } @mutex . unlock thread . wait # wait until function task has finished end end foo = Foo . new foo . main This code uses a shared resource (standard output). Inappropriate use of it causes the lines/letters to be randomly mixed or even crashes. To avoid this, we protect the corresponding region of the code with a mutex. The first thread that reaches its mutex.lock() line succeeds to lock the mutex, directly gains access to the code that follows and prints its text. When the other thread reaches its mutex.lock() line, the mutex is already locked and thus the thread is put to sleep (like SF.sleep , no CPU time is consumed by the sleeping thread). When the first thread finally unlocks the mutex, the second thread is awoken and is allowed to lock the mutex and print its text block as well. This leads to the lines of text appearing sequentially in the console instead of being mixed. I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one Mutexes are not the only primitive that you can use to protect your shared variables, but it should be enough for most cases. However, if your application does complicated things with threads, and you feel like it is not enough, don't hesitate to look for alternatives.","title":"Protecting shared data"},{"location":"system/thread.html#protecting-mutexes","text":"Don't worry: mutexes are already thread-safe, there's no need to protect them. But what if there is a failure in the code and the mutex never gets a chance to be unlocked? It remains locked forever. All threads that try to lock it in the future will block forever, and in some cases, your whole application could freeze. Pretty bad result. To make sure that mutexes are always unlocked in an environment where exceptions can be thrown, CrSFML provides a special method that receives a block: synchronize . The mutex is locked before the block and is unlocked after the block (even if an exception is raised). Thus, we can write previous code example in a simpler way, using synchronize like this: require \"crsfml/system\" class Foo @mutex = SF :: Mutex . new def task @mutex . synchronize do # lock mutex implicitly 7 . times { puts \"I'm thread number one\" } end # unlock mutex implicitly end def main thread = SF :: Thread . new ( -> task ) thread . launch @mutex . synchronize do # same as above 7 . times { puts \"I'm the main thread\" } end thread . wait end end foo = Foo . new foo . main","title":"Protecting mutexes"},{"location":"system/thread.html#common-mistakes","text":"One thing that is often overlooked by programmers is that a thread cannot live without its corresponding Thread instance. The following code is often seen: def func SF . sleep ( SF . seconds ( 10 )) end def start_thread SF :: Thread . new ( -> func ) . launch end start_thread () # ... Programmers who write this kind of code expect the start_thread function to start a thread that will live on its own and be destroyed when the threaded function ends. This is not what happens. The threaded function appears to block the main thread, as if the thread wasn't working. What is the cause of this? The Thread instance is local to the start_thread() function and is therefore destroyed, when the function returns. The finalizer of Thread is invoked, which calls wait() as we've learned above, and the result is that the main thread blocks and waits for the threaded function to be finished instead of continuing to run in parallel. So don't forget: You must manage your Thread instance so that it lives as long as the threaded function is supposed to run.","title":"Common mistakes"},{"location":"system/time.html","text":"Handling time Time in SFML Unlike many other libraries where time is a number of milliseconds, or a decimal number of seconds, SFML doesn't impose any specific unit or type for time values. Instead it leaves this choice to the user through a flexible class: Time . All SFML classes and functions that manipulate time values use this class. Time represents a time period (in other words, the time that elapses between two events). It is not a date-time class which would represent the current year/month/day/hour/minute/second as a timestamp, it's just a value that represents a certain amount of time, and how to interpret it depends on the context where it is used. Converting time A Time value can be constructed from different source units: seconds, milliseconds and microseconds. There is a (non-member) function to turn each of them into a Time : t1 = SF . microseconds ( 10000 ) t2 = SF . milliseconds ( 10 ) t3 = SF . seconds ( 0.01 ) Note that these three times are all equal. Similarly, a Time can be converted back to either seconds, milliseconds or microseconds: time = ... microseconds = time . as_microseconds milliseconds = time . as_milliseconds seconds = time . as_seconds Playing with time values Time is just an amount of time, so it supports arithmetic operations such as addition, subtraction, comparison, etc. Times can also be negative. t1 = ... t2 = t1 * 2 t3 = t1 + t2 t4 = - t3 b1 = ( t1 == t2 ) b2 = ( t3 > t4 ) Measuring time Relevant example: transformable Now that we've seen how to manipulate time values with CrSFML, let's see how to do something that almost every program needs: measuring the time elapsed. CrSFML has a very simple class for measuring time: Clock . It only has two methods: elapsed_time , to retrieve the time elapsed since the clock started, and restart , to restart the clock. clock = SF :: Clock . new # Starts the clock sleep ( 2 ) elapsed_1 = clock . elapsed_time p elapsed_1 . as_seconds clock . restart sleep ( 3 ) elapsed_2 = clock . elapsed_time p elapsed_2 . as_seconds Note that restart also returns the elapsed time, so that you can avoid the slight gap that would exist if you had to call elapsed_time explicitly before restart . Here is an example that uses the time elapsed at each iteration of the game loop to update the game logic: clock = SF :: Clock . new while window . open? elapsed = clock . restart update_game ( elapsed ) ... end","title":"Handling time"},{"location":"system/time.html#handling-time","text":"","title":"Handling time"},{"location":"system/time.html#time-in-sfml","text":"Unlike many other libraries where time is a number of milliseconds, or a decimal number of seconds, SFML doesn't impose any specific unit or type for time values. Instead it leaves this choice to the user through a flexible class: Time . All SFML classes and functions that manipulate time values use this class. Time represents a time period (in other words, the time that elapses between two events). It is not a date-time class which would represent the current year/month/day/hour/minute/second as a timestamp, it's just a value that represents a certain amount of time, and how to interpret it depends on the context where it is used.","title":"Time in SFML"},{"location":"system/time.html#converting-time","text":"A Time value can be constructed from different source units: seconds, milliseconds and microseconds. There is a (non-member) function to turn each of them into a Time : t1 = SF . microseconds ( 10000 ) t2 = SF . milliseconds ( 10 ) t3 = SF . seconds ( 0.01 ) Note that these three times are all equal. Similarly, a Time can be converted back to either seconds, milliseconds or microseconds: time = ... microseconds = time . as_microseconds milliseconds = time . as_milliseconds seconds = time . as_seconds","title":"Converting time"},{"location":"system/time.html#playing-with-time-values","text":"Time is just an amount of time, so it supports arithmetic operations such as addition, subtraction, comparison, etc. Times can also be negative. t1 = ... t2 = t1 * 2 t3 = t1 + t2 t4 = - t3 b1 = ( t1 == t2 ) b2 = ( t3 > t4 )","title":"Playing with time values"},{"location":"system/time.html#measuring-time","text":"Relevant example: transformable Now that we've seen how to manipulate time values with CrSFML, let's see how to do something that almost every program needs: measuring the time elapsed. CrSFML has a very simple class for measuring time: Clock . It only has two methods: elapsed_time , to retrieve the time elapsed since the clock started, and restart , to restart the clock. clock = SF :: Clock . new # Starts the clock sleep ( 2 ) elapsed_1 = clock . elapsed_time p elapsed_1 . as_seconds clock . restart sleep ( 3 ) elapsed_2 = clock . elapsed_time p elapsed_2 . as_seconds Note that restart also returns the elapsed time, so that you can avoid the slight gap that would exist if you had to call elapsed_time explicitly before restart . Here is an example that uses the time elapsed at each iteration of the game loop to update the game logic: clock = SF :: Clock . new while window . open? elapsed = clock . restart update_game ( elapsed ) ... end","title":"Measuring time"},{"location":"window/events.html","text":"Events explained Introduction This tutorial is a detailed list of window events. It describes them, and shows how to (and how not to) use them. The SF::Event type Before dealing with events, it is important to understand what the Event type is, and how to correctly use it. Event (unlike in SFML, where it is a union ) is just an abstract struct, and all the events are its subclasses. Many events have some data associated with them, so it is important to let the compiler know which exactly type of event is being inspected (using is_a? , as , case / when ), otherwise none of the members will be accessible. Here is the hierarchy: level 1 is the Event abstract struct itself, level 2 are abstract structs that add some members, and level 3 are concrete event types. The point of this is that that some events, while different (level 3), have exactly the same kind of information associated with them (level 2). Event \u251c\u2500\u2500\u2500\u2500\u2574Closed \u251c\u2500\u2574SizeEvent: height, width \u2502 \u2514\u2500\u2574Resized \u251c\u2500\u2500\u2500\u2500\u2574LostFocus \u251c\u2500\u2500\u2500\u2500\u2574GainedFocus \u251c\u2500\u2574TextEvent: unicode \u2502 \u2514\u2500\u2574TextEntered \u251c\u2500\u2574KeyEvent: code, alt, control, shift, system \u2502 \u251c\u2500\u2574KeyPressed \u2502 \u2514\u2500\u2574KeyReleased \u251c\u2500\u2574MouseWheelEvent: delta, x, y \u2502 \u2514\u2500\u2574MouseWheelMoved \u251c\u2500\u2574MouseWheelScrollEvent: wheel, delta, x, y \u2502 \u2514\u2500\u2574MouseWheelScrolled \u251c\u2500\u2574MouseButtonEvent: button, x, y \u2502 \u251c\u2500\u2574MouseButtonPressed \u2502 \u2514\u2500\u2574MouseButtonReleased \u251c\u2500\u2574MouseMoveEvent: x, y \u2502 \u2514\u2500\u2574MouseMoved \u251c\u2500\u2500\u2500\u2500\u2574MouseEntered \u251c\u2500\u2500\u2500\u2500\u2574MouseLeft \u251c\u2500\u2574JoystickButtonEvent: joystick_id, button \u2502 \u251c\u2500\u2574JoystickButtonPressed \u2502 \u2514\u2500\u2574JoystickButtonReleased \u251c\u2500\u2574JoystickMoveEvent: joystick_id, axis, position \u2502 \u2514\u2500\u2574JoystickMoved \u251c\u2500\u2574JoystickConnectEvent: joystick_id \u2502 \u251c\u2500\u2574JoystickConnected \u2502 \u2514\u2500\u2574JoystickDisconnected \u251c\u2500\u2574TouchEvent: finger, x, y \u2502 \u251c\u2500\u2574TouchBegan \u2502 \u251c\u2500\u2574TouchMoved \u2502 \u2514\u2500\u2574TouchEnded \u2514\u2500\u2574SensorEvent: type, x, y, z \u2514\u2500\u2574SensorChanged Event instances are filled by the poll_event (or wait_event ) method of the Window class. Only these two methods can produce valid events. To be clear, here is what a typical event loop looks like: # while there are pending events... while event = window . poll_event # check the type of the event... case event # window closed when SF :: Event :: Closed window . close # key pressed when SF :: Event :: KeyPressed ... # we don't process other types of events end end Alright, now we can see what events SFML supports, what they mean and how to use them properly. The Closed event Relevant example: simple The SF::Event::Closed event is triggered when the user wants to close the window, through any of the possible methods the window manager provides (\"close\" button, keyboard shortcut, etc.). This event only represents a close request, the window is not yet closed when the event is received. Typical code will just call window.close in reaction to this event, to actually close the window. However, you may also want to do something else first, like saving the current application state or asking the user what to do. If you don't do anything, the window remains open. There's no member associated with this event in the Event union. if event . is_a? SF :: Event :: Closed window . close end The Resized event Relevant example: gl The SF::Event::Resized event is triggered when the window is resized, either through user action or programmatically by calling window.size= . You can use this event to adjust the rendering settings: the viewport if you use OpenGL directly, or the current view if you use sfml-graphics. The data associated with this event is the new size of the window. if event . is_a? SF :: Event :: Resized puts \"new width: #{ event . width } \" puts \"new height: #{ event . height } \" end The LostFocus and GainedFocus events The SF::Event::LostFocus and SF::Event::GainedFocus events are triggered when the window loses/gains focus, which happens when the user switches the currently active window. When the window is out of focus, it doesn't receive keyboard events. This event can be used e.g. if you want to pause your game when the window is inactive. There's no member associated with these events in the Event union. if event . is_a? SF :: Event :: LostFocus my_game . pause end if event . is_a? SF :: Event :: GainedFocus my_game . resume end The TextEntered event Relevant example: typing The SF::Event::TextEntered event is triggered when a character is typed. This must not be confused with the KeyPressed event: TextEntered interprets the user input and produces the appropriate printable character. For example, pressing '^' then 'e' on a French keyboard will produce two KeyPressed events, but a single TextEntered event containing the '\u00ea' character. It works with all the input methods provided by the operating system, even the most specific or complex ones. This event is typically used to catch user input in a text field. The data associated with this event is the Unicode codepoint of the entered character (use .chr to convert it to a Char ). if event . is_a? SF :: Event :: TextEntered if event . unicode < 128 puts \"ASCII character typed: #{ event . unicode . chr } \" end end Note that, since they are part of the Unicode standard, some non-printable characters such as backspace are generated by this event. In most cases you'll need to filter them out. Many programmers use the KeyPressed event to get user input, and start to implement crazy algorithms that try to interpret all the possible key combinations to produce correct characters. Don't do that! The KeyPressed and KeyReleased events Relevant example: snakes The SF::Event::KeyPressed and SF::Event::KeyReleased events are triggered when a keyboard key is pressed/released. If a key is held, multiple KeyPressed events will be generated, at the default operating system delay (i. e. the same delay that applies when you hold a letter in a text editor). To disable repeated KeyPressed events, you can set window.key_repeat_enabled = false . On the flip side, it is obvious that KeyReleased events can never be repeated. This event is the one to use if you want to trigger an action exactly once when a key is pressed or released, like making a character jump with space, or exiting something with escape. Sometimes, people try to react to KeyPressed events directly to implement smooth movement. Doing so will not produce the expected effect, because when you hold a key you only get a few events (remember, the repeat delay). To achieve smooth movement with events, you must use a boolean that you set on KeyPressed and clear on KeyReleased ; you can then move (independently of events) as long as the boolean is set. The other (easier) solution to produce smooth movement is to use real-time keyboard input with Keyboard (see the dedicated tutorial ). The data associated with these events is the code of the pressed/released key, as well as the current state of the modifier keys (alt, control, shift, system). if event . is_a? SF :: Event :: KeyPressed if event . code == SF :: Keyboard :: Escape puts \"the escape key was pressed\" puts \"control: #{ event . control } \" puts \"alt: #{ event . alt } \" puts \"shift: #{ event . shift } \" puts \"system: #{ event . system } \" end end Note that some keys have a special meaning for the operating system, and will lead to unexpected behavior. An example is the F10 key on Windows, which \"steals\" the focus, or the F12 key which starts the debugger when using Visual Studio. This will probably be solved in a future version of SFML. The MouseWheelMoved event The SF::Event::MouseWheelMoved event is deprecated since SFML 2.3, use the MouseWheelScrolled event instead. The MouseWheelScrolled event Relevant example: diagnostics The SF::Event::MouseWheelScrolled event is triggered when a mouse wheel moves up or down, but also laterally if the mouse supports it. The data associated with this event contains the number of ticks the wheel has moved, what the orientation of the wheel is and the current position of the mouse cursor. if event . is_a? SF :: Event :: MouseWheelScrolled if event . wheel == SF :: Mouse :: VerticalWheel puts \"wheel type: vertical\" elsif event . wheel == SF :: Mouse :: HorizontalWheel puts \"wheel type: horizontal\" else puts \"wheel type: unknown\" end puts \"wheel movement: #{ event . delta } \" puts \"mouse x: #{ event . x } \" puts \"mouse y: #{ event . y } \" end The MouseButtonPressed and MouseButtonReleased events Relevant example: diagnostics The SF::Event::MouseButtonPressed and SF::Event::MouseButtonReleased events are triggered when a mouse button is pressed/released. SFML supports 5 mouse buttons: left, right, middle (wheel), extra #1 and extra #2 (side buttons). The data associated with these events contains the code of the pressed/released button, as well as the current position of the mouse cursor. if event . is_a? SF :: Event :: MouseButtonPressed if event . button . right? puts \"the right button was pressed\" puts \"mouse x: #{ event . x } \" puts \"mouse y: #{ event . y } \" end end The MouseMoved event The SF::Event::MouseMoved event is triggered when the mouse moves within the window. This event is triggered even if the window isn't focused. However, it is triggered only when the mouse moves within the inner area of the window, not when it moves over the title bar or borders. The data associated with this event contains the current position of the mouse cursor relative to the window. if event . is_a? SF :: Event :: MouseMoved puts \"new mouse x: #{ event . x } \" puts \"new mouse y: #{ event . y } \" end The MouseEntered and MouseLeft event The SF::Event::MouseEntered and SF::Event::MouseLeft events are triggered when the mouse cursor enters/leaves the window. There is no data associated with these events. case event when SF :: Event :: MouseEntered puts \"the mouse cursor has entered the window\" when SF :: Event :: MouseLeft puts \"the mouse cursor has left the window\" end The JoystickButtonPressed and JoystickButtonReleased events The SF::Event::JoystickButtonPressed and SF::Event::JoystickButtonReleased events are triggered when a joystick button is pressed/released. SFML supports up to 8 joysticks and 32 buttons. The data associated with these events contains the identifier of the joystick and the index of the pressed/released button. if event . is_a? SF :: Event :: JoystickButtonPressed puts \"joystick button pressed!\" puts \"joystick id: #{ event . joystick_id } \" puts \"button: #{ event . button } \" end The JoystickMoved event The SF::Event::JoystickMoved event is triggered when a joystick axis moves. Joystick axes are typically very sensitive, that's why SFML uses a detection threshold to avoid spamming your event loop with tons of JoystickMoved events. This threshold can be changed with the Window#joystick_threshold= method, in case you want to receive more or less joystick move events. SFML supports 8 joystick axes: X, Y, Z, R, U, V, POV X and POV Y. How they map to your joystick depends on its driver. The member associated with this event contains the identifier of the joystick, the name of the axis, and its current position (in the range [-100, 100]). if event . is_a? SF :: Event :: JoystickMoved if event . axis == SF :: Joystick :: X puts \"X axis moved!\" puts \"joystick id: #{ event . joystick_id } \" puts \"new position: #{ event . position } \" end end The JoystickConnected and JoystickDisconnected events The SF::Event::JoystickConnected and SF::Event::JoystickDisconnected events are triggered when a joystick is connected/disconnected. The data associated with this event is the identifier of the connected/disconnected joystick. case event when SF :: Event :: JoystickConnected puts \"joystick connected: #{ event . joystick_id } \" when SF :: Event :: JoystickDisconnected puts \"joystick disconnected: #{ event . joystick_id } \" end","title":"Events explained"},{"location":"window/events.html#events-explained","text":"","title":"Events explained"},{"location":"window/events.html#introduction","text":"This tutorial is a detailed list of window events. It describes them, and shows how to (and how not to) use them.","title":"Introduction"},{"location":"window/events.html#the-sfevent-type","text":"Before dealing with events, it is important to understand what the Event type is, and how to correctly use it. Event (unlike in SFML, where it is a union ) is just an abstract struct, and all the events are its subclasses. Many events have some data associated with them, so it is important to let the compiler know which exactly type of event is being inspected (using is_a? , as , case / when ), otherwise none of the members will be accessible. Here is the hierarchy: level 1 is the Event abstract struct itself, level 2 are abstract structs that add some members, and level 3 are concrete event types. The point of this is that that some events, while different (level 3), have exactly the same kind of information associated with them (level 2). Event \u251c\u2500\u2500\u2500\u2500\u2574Closed \u251c\u2500\u2574SizeEvent: height, width \u2502 \u2514\u2500\u2574Resized \u251c\u2500\u2500\u2500\u2500\u2574LostFocus \u251c\u2500\u2500\u2500\u2500\u2574GainedFocus \u251c\u2500\u2574TextEvent: unicode \u2502 \u2514\u2500\u2574TextEntered \u251c\u2500\u2574KeyEvent: code, alt, control, shift, system \u2502 \u251c\u2500\u2574KeyPressed \u2502 \u2514\u2500\u2574KeyReleased \u251c\u2500\u2574MouseWheelEvent: delta, x, y \u2502 \u2514\u2500\u2574MouseWheelMoved \u251c\u2500\u2574MouseWheelScrollEvent: wheel, delta, x, y \u2502 \u2514\u2500\u2574MouseWheelScrolled \u251c\u2500\u2574MouseButtonEvent: button, x, y \u2502 \u251c\u2500\u2574MouseButtonPressed \u2502 \u2514\u2500\u2574MouseButtonReleased \u251c\u2500\u2574MouseMoveEvent: x, y \u2502 \u2514\u2500\u2574MouseMoved \u251c\u2500\u2500\u2500\u2500\u2574MouseEntered \u251c\u2500\u2500\u2500\u2500\u2574MouseLeft \u251c\u2500\u2574JoystickButtonEvent: joystick_id, button \u2502 \u251c\u2500\u2574JoystickButtonPressed \u2502 \u2514\u2500\u2574JoystickButtonReleased \u251c\u2500\u2574JoystickMoveEvent: joystick_id, axis, position \u2502 \u2514\u2500\u2574JoystickMoved \u251c\u2500\u2574JoystickConnectEvent: joystick_id \u2502 \u251c\u2500\u2574JoystickConnected \u2502 \u2514\u2500\u2574JoystickDisconnected \u251c\u2500\u2574TouchEvent: finger, x, y \u2502 \u251c\u2500\u2574TouchBegan \u2502 \u251c\u2500\u2574TouchMoved \u2502 \u2514\u2500\u2574TouchEnded \u2514\u2500\u2574SensorEvent: type, x, y, z \u2514\u2500\u2574SensorChanged Event instances are filled by the poll_event (or wait_event ) method of the Window class. Only these two methods can produce valid events. To be clear, here is what a typical event loop looks like: # while there are pending events... while event = window . poll_event # check the type of the event... case event # window closed when SF :: Event :: Closed window . close # key pressed when SF :: Event :: KeyPressed ... # we don't process other types of events end end Alright, now we can see what events SFML supports, what they mean and how to use them properly.","title":"The SF::Event type"},{"location":"window/events.html#the-closed-event","text":"Relevant example: simple The SF::Event::Closed event is triggered when the user wants to close the window, through any of the possible methods the window manager provides (\"close\" button, keyboard shortcut, etc.). This event only represents a close request, the window is not yet closed when the event is received. Typical code will just call window.close in reaction to this event, to actually close the window. However, you may also want to do something else first, like saving the current application state or asking the user what to do. If you don't do anything, the window remains open. There's no member associated with this event in the Event union. if event . is_a? SF :: Event :: Closed window . close end","title":"The Closed event"},{"location":"window/events.html#the-resized-event","text":"Relevant example: gl The SF::Event::Resized event is triggered when the window is resized, either through user action or programmatically by calling window.size= . You can use this event to adjust the rendering settings: the viewport if you use OpenGL directly, or the current view if you use sfml-graphics. The data associated with this event is the new size of the window. if event . is_a? SF :: Event :: Resized puts \"new width: #{ event . width } \" puts \"new height: #{ event . height } \" end","title":"The Resized event"},{"location":"window/events.html#the-lostfocus-and-gainedfocus-events","text":"The SF::Event::LostFocus and SF::Event::GainedFocus events are triggered when the window loses/gains focus, which happens when the user switches the currently active window. When the window is out of focus, it doesn't receive keyboard events. This event can be used e.g. if you want to pause your game when the window is inactive. There's no member associated with these events in the Event union. if event . is_a? SF :: Event :: LostFocus my_game . pause end if event . is_a? SF :: Event :: GainedFocus my_game . resume end","title":"The LostFocus and GainedFocus events"},{"location":"window/events.html#the-textentered-event","text":"Relevant example: typing The SF::Event::TextEntered event is triggered when a character is typed. This must not be confused with the KeyPressed event: TextEntered interprets the user input and produces the appropriate printable character. For example, pressing '^' then 'e' on a French keyboard will produce two KeyPressed events, but a single TextEntered event containing the '\u00ea' character. It works with all the input methods provided by the operating system, even the most specific or complex ones. This event is typically used to catch user input in a text field. The data associated with this event is the Unicode codepoint of the entered character (use .chr to convert it to a Char ). if event . is_a? SF :: Event :: TextEntered if event . unicode < 128 puts \"ASCII character typed: #{ event . unicode . chr } \" end end Note that, since they are part of the Unicode standard, some non-printable characters such as backspace are generated by this event. In most cases you'll need to filter them out. Many programmers use the KeyPressed event to get user input, and start to implement crazy algorithms that try to interpret all the possible key combinations to produce correct characters. Don't do that!","title":"The TextEntered event"},{"location":"window/events.html#the-keypressed-and-keyreleased-events","text":"Relevant example: snakes The SF::Event::KeyPressed and SF::Event::KeyReleased events are triggered when a keyboard key is pressed/released. If a key is held, multiple KeyPressed events will be generated, at the default operating system delay (i. e. the same delay that applies when you hold a letter in a text editor). To disable repeated KeyPressed events, you can set window.key_repeat_enabled = false . On the flip side, it is obvious that KeyReleased events can never be repeated. This event is the one to use if you want to trigger an action exactly once when a key is pressed or released, like making a character jump with space, or exiting something with escape. Sometimes, people try to react to KeyPressed events directly to implement smooth movement. Doing so will not produce the expected effect, because when you hold a key you only get a few events (remember, the repeat delay). To achieve smooth movement with events, you must use a boolean that you set on KeyPressed and clear on KeyReleased ; you can then move (independently of events) as long as the boolean is set. The other (easier) solution to produce smooth movement is to use real-time keyboard input with Keyboard (see the dedicated tutorial ). The data associated with these events is the code of the pressed/released key, as well as the current state of the modifier keys (alt, control, shift, system). if event . is_a? SF :: Event :: KeyPressed if event . code == SF :: Keyboard :: Escape puts \"the escape key was pressed\" puts \"control: #{ event . control } \" puts \"alt: #{ event . alt } \" puts \"shift: #{ event . shift } \" puts \"system: #{ event . system } \" end end Note that some keys have a special meaning for the operating system, and will lead to unexpected behavior. An example is the F10 key on Windows, which \"steals\" the focus, or the F12 key which starts the debugger when using Visual Studio. This will probably be solved in a future version of SFML.","title":"The KeyPressed and KeyReleased events"},{"location":"window/events.html#the-mousewheelmoved-event","text":"The SF::Event::MouseWheelMoved event is deprecated since SFML 2.3, use the MouseWheelScrolled event instead.","title":"The MouseWheelMoved event"},{"location":"window/events.html#the-mousewheelscrolled-event","text":"Relevant example: diagnostics The SF::Event::MouseWheelScrolled event is triggered when a mouse wheel moves up or down, but also laterally if the mouse supports it. The data associated with this event contains the number of ticks the wheel has moved, what the orientation of the wheel is and the current position of the mouse cursor. if event . is_a? SF :: Event :: MouseWheelScrolled if event . wheel == SF :: Mouse :: VerticalWheel puts \"wheel type: vertical\" elsif event . wheel == SF :: Mouse :: HorizontalWheel puts \"wheel type: horizontal\" else puts \"wheel type: unknown\" end puts \"wheel movement: #{ event . delta } \" puts \"mouse x: #{ event . x } \" puts \"mouse y: #{ event . y } \" end","title":"The MouseWheelScrolled event"},{"location":"window/events.html#the-mousebuttonpressed-and-mousebuttonreleased-events","text":"Relevant example: diagnostics The SF::Event::MouseButtonPressed and SF::Event::MouseButtonReleased events are triggered when a mouse button is pressed/released. SFML supports 5 mouse buttons: left, right, middle (wheel), extra #1 and extra #2 (side buttons). The data associated with these events contains the code of the pressed/released button, as well as the current position of the mouse cursor. if event . is_a? SF :: Event :: MouseButtonPressed if event . button . right? puts \"the right button was pressed\" puts \"mouse x: #{ event . x } \" puts \"mouse y: #{ event . y } \" end end","title":"The MouseButtonPressed and MouseButtonReleased events"},{"location":"window/events.html#the-mousemoved-event","text":"The SF::Event::MouseMoved event is triggered when the mouse moves within the window. This event is triggered even if the window isn't focused. However, it is triggered only when the mouse moves within the inner area of the window, not when it moves over the title bar or borders. The data associated with this event contains the current position of the mouse cursor relative to the window. if event . is_a? SF :: Event :: MouseMoved puts \"new mouse x: #{ event . x } \" puts \"new mouse y: #{ event . y } \" end","title":"The MouseMoved event"},{"location":"window/events.html#the-mouseentered-and-mouseleft-event","text":"The SF::Event::MouseEntered and SF::Event::MouseLeft events are triggered when the mouse cursor enters/leaves the window. There is no data associated with these events. case event when SF :: Event :: MouseEntered puts \"the mouse cursor has entered the window\" when SF :: Event :: MouseLeft puts \"the mouse cursor has left the window\" end","title":"The MouseEntered and MouseLeft event"},{"location":"window/events.html#the-joystickbuttonpressed-and-joystickbuttonreleased-events","text":"The SF::Event::JoystickButtonPressed and SF::Event::JoystickButtonReleased events are triggered when a joystick button is pressed/released. SFML supports up to 8 joysticks and 32 buttons. The data associated with these events contains the identifier of the joystick and the index of the pressed/released button. if event . is_a? SF :: Event :: JoystickButtonPressed puts \"joystick button pressed!\" puts \"joystick id: #{ event . joystick_id } \" puts \"button: #{ event . button } \" end","title":"The JoystickButtonPressed and JoystickButtonReleased events"},{"location":"window/events.html#the-joystickmoved-event","text":"The SF::Event::JoystickMoved event is triggered when a joystick axis moves. Joystick axes are typically very sensitive, that's why SFML uses a detection threshold to avoid spamming your event loop with tons of JoystickMoved events. This threshold can be changed with the Window#joystick_threshold= method, in case you want to receive more or less joystick move events. SFML supports 8 joystick axes: X, Y, Z, R, U, V, POV X and POV Y. How they map to your joystick depends on its driver. The member associated with this event contains the identifier of the joystick, the name of the axis, and its current position (in the range [-100, 100]). if event . is_a? SF :: Event :: JoystickMoved if event . axis == SF :: Joystick :: X puts \"X axis moved!\" puts \"joystick id: #{ event . joystick_id } \" puts \"new position: #{ event . position } \" end end","title":"The JoystickMoved event"},{"location":"window/events.html#the-joystickconnected-and-joystickdisconnected-events","text":"The SF::Event::JoystickConnected and SF::Event::JoystickDisconnected events are triggered when a joystick is connected/disconnected. The data associated with this event is the identifier of the connected/disconnected joystick. case event when SF :: Event :: JoystickConnected puts \"joystick connected: #{ event . joystick_id } \" when SF :: Event :: JoystickDisconnected puts \"joystick disconnected: #{ event . joystick_id } \" end","title":"The JoystickConnected and JoystickDisconnected events"},{"location":"window/inputs.html","text":"Keyboard, mouse and joystick Relevant example: diagnostics Introduction This tutorial explains how to access global input devices: keyboard, mouse and joysticks. This must not be confused with events. Real-time input allows you to query the global state of keyboard, mouse and joysticks at any time (\" is this button currently pressed? \", \" where is the mouse currently? \") while events notify you when something happens (\" this button was pressed \", \" the mouse has moved \"). Keyboard The class that provides access to the keyboard state is Keyboard . It only contains one class method, key_pressed? , which checks the current state of a key (pressed or released). It is a class method, so you don't need to instantiate Keyboard to use it. This class method directly reads the keyboard state, ignoring the focus state of your window. This means that key_pressed? may return true even if your window is inactive. if SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Left ) # left key is pressed: move our character character . move ( 1 , 0 ) end Key codes are defined in the SF::Keyboard::Key enum. Depending on your operating system and keyboard layout, some key codes might be missing or interpreted incorrectly. This is something that will be improved in a future version of SFML. Mouse The class that provides access to the mouse state is Mouse . Like its friend Keyboard , Mouse only contains class methods and is not meant to be instantiated (SFML only handles a single mouse for the time being). You can check if buttons are pressed: if SF :: Mouse . button_pressed? ( SF :: Mouse :: Left ) # left mouse button is pressed: shoot gun . fire end Mouse button codes are defined in the SF::Mouse::Button enum. SFML supports up to 5 buttons: left, right, middle (wheel), and two additional buttons whatever they may be. You can also get and set the current position of the mouse, either relative to the desktop or to a window: # get the global mouse position (relative to the desktop) global_position = SF :: Mouse . position # get the local mouse position (relative to a window) local_position = SF :: Mouse . get_position ( window ) # window is a SF::Window # set the mouse position globally (relative to the desktop) SF :: Mouse . position = SF . vector2 ( 10 , 50 ) # set the mouse position locally (relative to a window) SF :: Mouse . set_position ( SF . vector2 ( 10 , 50 ), window ) # window is a SF::Window There is no function for reading the current state of the mouse wheel. Since the wheel can only be moved relatively, it has no absolute state that can be queried. By looking at a key you can tell whether it's pressed or released. By looking at the mouse cursor you can tell where it is located on the screen. However, looking at the mouse wheel doesn't tell you which \"tick\" it is on. You can only be notified when it moves ( MouseWheelMoved event). Joystick The class that provides access to the joysticks' states is Joystick . Like the other classes in this tutorial, it only contains class methods. Joysticks are identified by their index (0 to 7, since SFML supports up to 8 joysticks). Therefore, the first argument of every class method of Joystick is the index of the joystick that you want to query. You can check whether a joystick is connected or not: if SF :: Joystick . connected? ( 0 ) # joystick number 0 is connected ... end You can also get the capabilities of a connected joystick: # check how many buttons joystick number 0 has button_count = SF :: Joystick . get_button_count ( 0 ) # check if joystick number 0 has a Z axis has_z = SF :: Joystick . axis? ( 0 , SF :: Joystick :: Z ) Joystick axes are defined in the SF::Joystick::Axis enum. Since buttons have no special meaning, they are simply numbered from 0 to 31. Finally, you can query the state of a joystick's axes and buttons as well: # is button 1 of joystick number 0 pressed? if SF :: Joystick . button_pressed? ( 0 , 1 ) # yes: shoot! gun . fire end # what's the current position of the X and Y axes of joystick number 0? x = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: X ) y = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: Y ) character . move ( x , y ) Joystick states are automatically updated when you check for events. If you don't check for events, or need to query a joystick state (for example, checking which joysticks are connected) before starting your game loop, you'll have to manually call the SF::Joystick.update class method yourself to make sure that the joystick states are up to date.","title":"Keyboard, mouse and joysticks"},{"location":"window/inputs.html#keyboard-mouse-and-joystick","text":"Relevant example: diagnostics","title":"Keyboard, mouse and joystick"},{"location":"window/inputs.html#introduction","text":"This tutorial explains how to access global input devices: keyboard, mouse and joysticks. This must not be confused with events. Real-time input allows you to query the global state of keyboard, mouse and joysticks at any time (\" is this button currently pressed? \", \" where is the mouse currently? \") while events notify you when something happens (\" this button was pressed \", \" the mouse has moved \").","title":"Introduction"},{"location":"window/inputs.html#keyboard","text":"The class that provides access to the keyboard state is Keyboard . It only contains one class method, key_pressed? , which checks the current state of a key (pressed or released). It is a class method, so you don't need to instantiate Keyboard to use it. This class method directly reads the keyboard state, ignoring the focus state of your window. This means that key_pressed? may return true even if your window is inactive. if SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Left ) # left key is pressed: move our character character . move ( 1 , 0 ) end Key codes are defined in the SF::Keyboard::Key enum. Depending on your operating system and keyboard layout, some key codes might be missing or interpreted incorrectly. This is something that will be improved in a future version of SFML.","title":"Keyboard"},{"location":"window/inputs.html#mouse","text":"The class that provides access to the mouse state is Mouse . Like its friend Keyboard , Mouse only contains class methods and is not meant to be instantiated (SFML only handles a single mouse for the time being). You can check if buttons are pressed: if SF :: Mouse . button_pressed? ( SF :: Mouse :: Left ) # left mouse button is pressed: shoot gun . fire end Mouse button codes are defined in the SF::Mouse::Button enum. SFML supports up to 5 buttons: left, right, middle (wheel), and two additional buttons whatever they may be. You can also get and set the current position of the mouse, either relative to the desktop or to a window: # get the global mouse position (relative to the desktop) global_position = SF :: Mouse . position # get the local mouse position (relative to a window) local_position = SF :: Mouse . get_position ( window ) # window is a SF::Window # set the mouse position globally (relative to the desktop) SF :: Mouse . position = SF . vector2 ( 10 , 50 ) # set the mouse position locally (relative to a window) SF :: Mouse . set_position ( SF . vector2 ( 10 , 50 ), window ) # window is a SF::Window There is no function for reading the current state of the mouse wheel. Since the wheel can only be moved relatively, it has no absolute state that can be queried. By looking at a key you can tell whether it's pressed or released. By looking at the mouse cursor you can tell where it is located on the screen. However, looking at the mouse wheel doesn't tell you which \"tick\" it is on. You can only be notified when it moves ( MouseWheelMoved event).","title":"Mouse"},{"location":"window/inputs.html#joystick","text":"The class that provides access to the joysticks' states is Joystick . Like the other classes in this tutorial, it only contains class methods. Joysticks are identified by their index (0 to 7, since SFML supports up to 8 joysticks). Therefore, the first argument of every class method of Joystick is the index of the joystick that you want to query. You can check whether a joystick is connected or not: if SF :: Joystick . connected? ( 0 ) # joystick number 0 is connected ... end You can also get the capabilities of a connected joystick: # check how many buttons joystick number 0 has button_count = SF :: Joystick . get_button_count ( 0 ) # check if joystick number 0 has a Z axis has_z = SF :: Joystick . axis? ( 0 , SF :: Joystick :: Z ) Joystick axes are defined in the SF::Joystick::Axis enum. Since buttons have no special meaning, they are simply numbered from 0 to 31. Finally, you can query the state of a joystick's axes and buttons as well: # is button 1 of joystick number 0 pressed? if SF :: Joystick . button_pressed? ( 0 , 1 ) # yes: shoot! gun . fire end # what's the current position of the X and Y axes of joystick number 0? x = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: X ) y = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: Y ) character . move ( x , y ) Joystick states are automatically updated when you check for events. If you don't check for events, or need to query a joystick state (for example, checking which joysticks are connected) before starting your game loop, you'll have to manually call the SF::Joystick.update class method yourself to make sure that the joystick states are up to date.","title":"Joystick"},{"location":"window/opengl.html","text":"Using OpenGL in an SFML window Relevant examples: gl , cube Introduction This tutorial is not about OpenGL itself, but rather how to use CrSFML as an environment for OpenGL, and how to mix them together. As you know, one of the most important features of OpenGL is portability. But OpenGL alone won't be enough to create complete programs: you need a window, a rendering context, user input, etc. You would have no choice but to write OS-specific code to handle this stuff on your own. That's where the sfml-window module comes into play. Let's see how it allows you to play with OpenGL. OpenGL? To use OpenGL, you'll need to find a library that implements Crystal bindings to it. This tutorial also contains small bits of OpenGL bindings. Creating an OpenGL window Since SFML is based on OpenGL, its windows are ready for OpenGL calls without any extra effort. @[ Link ( \"GL\" ) ] # Use @[Link(framework: \"OpenGL\")] on Mac OSX lib GL fun enable = glEnable ( cap : Int32 ) TEXTURE_2D = 3553 end window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" ) # it works out of the box GL . enable ( GL :: TEXTURE_2D ) ... In case you think it is too automatic, Window 's constructor has an extra argument that allows you to change the settings of the underlying OpenGL context. This argument is an instance of the structure, it provides access to the following settings: depth_bits is the number of bits per pixel to use for the depth buffer (0 to disable it) stencil_bits is the number of bits per pixel to use for the stencil buffer (0 to disable it) antialiasing_level is the multisampling level major_version and minor_version comprise the requested version of OpenGL settings = SF :: ContextSettings . new ( depth : 24 , stencil : 8 , antialiasing : 4 , major : 3 , minor : 0 ) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" , settings : settings ) If any of these settings is not supported by the graphics card, SFML tries to find the closest valid match. For example, if 4x anti-aliasing is too high, it tries 2x and then falls back to 0. In any case, you can check what settings SFML actually used with the settings method: settings = window . settings puts \"depth bits: #{ settings . depth_bits } \" puts \"stencil bits: #{ settings . stencil_bits } \" puts \"antialiasing level: #{ settings . antialiasing_level } \" puts \"version: #{ settings . major_version } . #{ settings . minor_version } \" OpenGL versions above 3.0 are supported by SFML (as long as your graphics driver can handle them). Support for selecting the profile of 3.2+ contexts and whether the context debug flag is set was added in SFML 2.3. The forward compatibility flag is not supported. By default, SFML creates 3.2+ contexts using the compatibility profile because the graphics module makes use of legacy OpenGL functionality. If you intend on using the graphics module, make sure to create your context without the core profile setting or the graphics module will not function correctly. On OS X, SFML supports creating OpenGL 3.2+ contexts using the core profile only. If you want to use the graphics module on OS X, you are limited to using a legacy context which implies OpenGL version 2.1. A typical OpenGL-with-CrSFML program Here is what a complete OpenGL program would look like with CrSFML: require \"crsfml\" # create bindings @[ Link ( \"GL\" ) ] lib GL fun enable = glEnable ( cap : Int32 ) fun viewport = glViewport ( x : Int32 , y : Int32 , width : Int32 , height : Int32 ) fun clear = glClear ( mask : Int32 ) TEXTURE_2D = 3553 COLOR_BUFFER_BIT = 16384 DEPTH_BUFFER_BIT = 256 end GL . enable ( GL :: TEXTURE_2D ) # create the window settings = SF :: ContextSettings . new ( 32 ) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" , settings : settings ) window . vertical_sync_enabled = true # load resources, initialize the OpenGL states, ... # run the main loop running = true while running # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed # end the program running = false elsif event . is_a? SF :: Event :: Resized # adjust the viewport when the window is resized GL . viewport ( 0 , 0 , event . width , event . height ) end end # clear the buffers GL . clear ( GL :: COLOR_BUFFER_BIT | GL :: DEPTH_BUFFER_BIT ) # draw... # end the current frame (internally swaps the front and back buffers) window . display end Here we don't use window.open? as the condition of the main loop, because we need the window to remain open until the program ends, so that we still have a valid OpenGL context for the last iteration of the loop and the cleanup code. Don't hesitate to have a look at the \"OpenGL\" and \"Window\" examples in the SFML SDK if you have further problems, they are more complete and most likely contain solutions to your problems. Managing multiple OpenGL windows Managing multiple OpenGL windows is not more complicated than managing one, there are just a few things to keep in mind. OpenGL calls are made on the active context (thus the active window). Therefore if you want to draw to two different windows within the same program, you have to select which window is active before drawing something. This can be done with the active= method: # activate the first window window1 . active = true # draw to the first window... # activate the second window window2 . active = true # draw to the second window... Only one context (window) can be active in a thread, so you don't need to deactivate a window before activating another one, it is deactivated automatically. This is how OpenGL works. Another thing to know is that all the OpenGL contexts created by SFML share their resources. This means that you can create a texture or vertex buffer with any context active, and use it with any other. This also means that you don't have to reload all your OpenGL resources when you recreate your window. Only shareable OpenGL resources can be shared among contexts. An example of an unshareable resource is a vertex array object. Using OpenGL together with the graphics module This tutorial was about mixing OpenGL with sfml-window, which is fairly easy since it's the only purpose of this module. Mixing with the graphics module is a little more complicated: sfml-graphics uses OpenGL too, so extra care must be taken so that SFML and user states don't conflict with each other. If you don't know the graphics module yet, all you have to know is that the Window class is replaced with RenderWindow , which inherits all its methods and adds features to draw SFML specific entities. The only way to avoid conflicts between SFML and your own OpenGL states, is to save/restore them every time you switch from OpenGL to SFML. draw with OpenGL save OpenGL states draw with SFML restore OpenGL states draw with OpenGL ... The easiest solution is to let CrSFML do it for you, with the push_gl_states / pop_gl_states methods: glDraw ... window . push_gl_states window . draw ( ... ) window . pop_gl_states glDraw ... Since it has no knowledge about your OpenGL code, SFML can't optimize these steps and as a result it saves/restores all available OpenGL states and matrices. This may be acceptable for small projects, but it might also be too slow for bigger programs that require maximum performance. In this case, you can handle saving and restoring the OpenGL states yourself, with glPushAttrib / glPopAttrib , glPushMatrix / glPopMatrix , etc. If you do this, you'll still need to restore SFML's own states before drawing. This is done with the reset_gl_states method. glDraw ... glPush ... window . reset_gl_states window . draw ( ... ) glPop ... glDraw ... By saving and restoring OpenGL states yourself, you can manage only the ones that you really need which leads to reducing the number of unnecessary driver calls.","title":"Using OpenGL in an SFML window"},{"location":"window/opengl.html#using-opengl-in-an-sfml-window","text":"Relevant examples: gl , cube","title":"Using OpenGL in an SFML window"},{"location":"window/opengl.html#introduction","text":"This tutorial is not about OpenGL itself, but rather how to use CrSFML as an environment for OpenGL, and how to mix them together. As you know, one of the most important features of OpenGL is portability. But OpenGL alone won't be enough to create complete programs: you need a window, a rendering context, user input, etc. You would have no choice but to write OS-specific code to handle this stuff on your own. That's where the sfml-window module comes into play. Let's see how it allows you to play with OpenGL.","title":"Introduction"},{"location":"window/opengl.html#opengl","text":"To use OpenGL, you'll need to find a library that implements Crystal bindings to it. This tutorial also contains small bits of OpenGL bindings.","title":"OpenGL?"},{"location":"window/opengl.html#creating-an-opengl-window","text":"Since SFML is based on OpenGL, its windows are ready for OpenGL calls without any extra effort. @[ Link ( \"GL\" ) ] # Use @[Link(framework: \"OpenGL\")] on Mac OSX lib GL fun enable = glEnable ( cap : Int32 ) TEXTURE_2D = 3553 end window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" ) # it works out of the box GL . enable ( GL :: TEXTURE_2D ) ... In case you think it is too automatic, Window 's constructor has an extra argument that allows you to change the settings of the underlying OpenGL context. This argument is an instance of the structure, it provides access to the following settings: depth_bits is the number of bits per pixel to use for the depth buffer (0 to disable it) stencil_bits is the number of bits per pixel to use for the stencil buffer (0 to disable it) antialiasing_level is the multisampling level major_version and minor_version comprise the requested version of OpenGL settings = SF :: ContextSettings . new ( depth : 24 , stencil : 8 , antialiasing : 4 , major : 3 , minor : 0 ) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" , settings : settings ) If any of these settings is not supported by the graphics card, SFML tries to find the closest valid match. For example, if 4x anti-aliasing is too high, it tries 2x and then falls back to 0. In any case, you can check what settings SFML actually used with the settings method: settings = window . settings puts \"depth bits: #{ settings . depth_bits } \" puts \"stencil bits: #{ settings . stencil_bits } \" puts \"antialiasing level: #{ settings . antialiasing_level } \" puts \"version: #{ settings . major_version } . #{ settings . minor_version } \" OpenGL versions above 3.0 are supported by SFML (as long as your graphics driver can handle them). Support for selecting the profile of 3.2+ contexts and whether the context debug flag is set was added in SFML 2.3. The forward compatibility flag is not supported. By default, SFML creates 3.2+ contexts using the compatibility profile because the graphics module makes use of legacy OpenGL functionality. If you intend on using the graphics module, make sure to create your context without the core profile setting or the graphics module will not function correctly. On OS X, SFML supports creating OpenGL 3.2+ contexts using the core profile only. If you want to use the graphics module on OS X, you are limited to using a legacy context which implies OpenGL version 2.1.","title":"Creating an OpenGL window"},{"location":"window/opengl.html#a-typical-opengl-with-crsfml-program","text":"Here is what a complete OpenGL program would look like with CrSFML: require \"crsfml\" # create bindings @[ Link ( \"GL\" ) ] lib GL fun enable = glEnable ( cap : Int32 ) fun viewport = glViewport ( x : Int32 , y : Int32 , width : Int32 , height : Int32 ) fun clear = glClear ( mask : Int32 ) TEXTURE_2D = 3553 COLOR_BUFFER_BIT = 16384 DEPTH_BUFFER_BIT = 256 end GL . enable ( GL :: TEXTURE_2D ) # create the window settings = SF :: ContextSettings . new ( 32 ) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" , settings : settings ) window . vertical_sync_enabled = true # load resources, initialize the OpenGL states, ... # run the main loop running = true while running # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed # end the program running = false elsif event . is_a? SF :: Event :: Resized # adjust the viewport when the window is resized GL . viewport ( 0 , 0 , event . width , event . height ) end end # clear the buffers GL . clear ( GL :: COLOR_BUFFER_BIT | GL :: DEPTH_BUFFER_BIT ) # draw... # end the current frame (internally swaps the front and back buffers) window . display end Here we don't use window.open? as the condition of the main loop, because we need the window to remain open until the program ends, so that we still have a valid OpenGL context for the last iteration of the loop and the cleanup code. Don't hesitate to have a look at the \"OpenGL\" and \"Window\" examples in the SFML SDK if you have further problems, they are more complete and most likely contain solutions to your problems.","title":"A typical OpenGL-with-CrSFML program"},{"location":"window/opengl.html#managing-multiple-opengl-windows","text":"Managing multiple OpenGL windows is not more complicated than managing one, there are just a few things to keep in mind. OpenGL calls are made on the active context (thus the active window). Therefore if you want to draw to two different windows within the same program, you have to select which window is active before drawing something. This can be done with the active= method: # activate the first window window1 . active = true # draw to the first window... # activate the second window window2 . active = true # draw to the second window... Only one context (window) can be active in a thread, so you don't need to deactivate a window before activating another one, it is deactivated automatically. This is how OpenGL works. Another thing to know is that all the OpenGL contexts created by SFML share their resources. This means that you can create a texture or vertex buffer with any context active, and use it with any other. This also means that you don't have to reload all your OpenGL resources when you recreate your window. Only shareable OpenGL resources can be shared among contexts. An example of an unshareable resource is a vertex array object.","title":"Managing multiple OpenGL windows"},{"location":"window/opengl.html#using-opengl-together-with-the-graphics-module","text":"This tutorial was about mixing OpenGL with sfml-window, which is fairly easy since it's the only purpose of this module. Mixing with the graphics module is a little more complicated: sfml-graphics uses OpenGL too, so extra care must be taken so that SFML and user states don't conflict with each other. If you don't know the graphics module yet, all you have to know is that the Window class is replaced with RenderWindow , which inherits all its methods and adds features to draw SFML specific entities. The only way to avoid conflicts between SFML and your own OpenGL states, is to save/restore them every time you switch from OpenGL to SFML. draw with OpenGL save OpenGL states draw with SFML restore OpenGL states draw with OpenGL ... The easiest solution is to let CrSFML do it for you, with the push_gl_states / pop_gl_states methods: glDraw ... window . push_gl_states window . draw ( ... ) window . pop_gl_states glDraw ... Since it has no knowledge about your OpenGL code, SFML can't optimize these steps and as a result it saves/restores all available OpenGL states and matrices. This may be acceptable for small projects, but it might also be too slow for bigger programs that require maximum performance. In this case, you can handle saving and restoring the OpenGL states yourself, with glPushAttrib / glPopAttrib , glPushMatrix / glPopMatrix , etc. If you do this, you'll still need to restore SFML's own states before drawing. This is done with the reset_gl_states method. glDraw ... glPush ... window . reset_gl_states window . draw ( ... ) glPop ... glDraw ... By saving and restoring OpenGL states yourself, you can manage only the ones that you really need which leads to reducing the number of unnecessary driver calls.","title":"Using OpenGL together with the graphics module"},{"location":"window/window.html","text":"Opening and managing an SFML window Relevant example: simple Introduction This tutorial only explains how to open and manage a window. Drawing stuff is beyond the scope of the sfml-window module: it is handled by the sfml-graphics module. However, the window management remains exactly the same so reading this tutorial is important in any case. Opening a window Windows in CrSFML are defined by the Window class. A window can be created and opened directly upon construction: require \"crsfml\" window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) ... The first argument, the video mode , defines the size of the window (the inner size, without the title bar and borders). Here, we create a window with a size of 800x600 pixels. The VideoMode class has some interesting class methods to get the desktop resolution, or the list of valid video modes for fullscreen mode. Don't hesitate to have a look at its documentation. The second argument is simply the title of the window. This constructor accepts a third optional argument: a style, which allows you to choose which decorations and features you want. You can use any combination of the following styles: SF::Style::None No decoration at all (useful for splash screens, for example); this style cannot be combined with others SF::Style::Titlebar The window has a titlebar SF::Style::Resize The window can be resized and has a maximize button SF::Style::Close The window has a close button SF::Style::Fullscreen The window is shown in fullscreen mode; this style cannot be combined with others, and requires a valid video mode SF::Style::Default The default style, which is a shortcut for Titlebar | Resize | Close There's also a fourth optional argument, which defines OpenGL specific options which are explained in the dedicated OpenGL tutorial . Bringing the window to life If you try to execute the code above with nothing in place of the \"...\", you will hardly see anything. First, because the program ends immediately. Second, because there's no event handling -- so even if you added an endless loop to this code, you would see a dead window, unable to be resized or closed. Let's add some code to make this program a bit more interesting: require \"crsfml\" window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) # run the program as long as the window is open while window . open? # check all the window's events that were triggered since the last iteration of the loop while event = window . poll_event # \"close requested\" event: we close the window if event . is_a? SF :: Event :: Closed window . close end end end The above code will open a window, and terminate when the user closes it. Let's see how it works in detail. First, we added a loop that ensures that the application will be refreshed/updated until the window is closed. Most (if not all) CrSFML programs will have this kind of loop, sometimes called the main loop or game loop . Then, the first thing that we want to do inside our game loop is check for any events that occurred. Note that we use a while loop so that all pending events are processed in case there were several. The poll_event method returns an event if there was one pending, or nil otherwise. Whenever we get an event, we must check its type (window closed? key pressed? mouse moved? joystick connected? ...), and react accordingly if we are interested in it. In this case, we only care about the Event::Closed event, which is triggered when the user wants to close the window. At this point, the window is still open and we have to close it explicitly with the close method. This enables you to do something before the window is closed, such as saving the current state of the application, or displaying a message. A mistake that people often make is to forget the event loop, simply because they don't yet care about handling events (they use real-time inputs instead). Without an event loop, the window will become unresponsive. It is important to note that the event loop has two roles: in addition to providing events to the user, it gives the window a chance to process its internal events too, which is required so that it can react to move or resize user actions. After the window has been closed, the main loop exits and the program terminates. At this point, you probably noticed that we haven't talked about drawing something to the window yet. As stated in the introduction, this is not the job of the sfml-window module, and you'll have to jump to the sfml-graphics tutorials if you want to draw things such as sprites, text or shapes. To draw stuff, you can also use OpenGL directly and totally ignore the sfml-graphics module. Window internally creates an OpenGL context and is ready to accept your OpenGL calls. You can learn more about that in the corresponding tutorial . Don't expect to see anything interesting in this window: you may see a uniform color (black or white), or the last contents of the previous application that used OpenGL, or... something else. Playing with the window Of course, CrSFML allows you to play with your windows a bit. Basic window operations such as changing the size, position, title or icon are supported, but unlike dedicated GUI libraries, SFML doesn't provide advanced features. SFML windows are only meant to provide an environment for OpenGL or SFML drawing. # change the position of the window (relatively to the desktop) window . position = SF . vector2 ( 10 , 50 ) # change the size of the window window . size = SF . vector2 ( 640 , 480 ) # change the title of the window window . title = \"SFML window\" # get the size of the window size = window . size width = size . x height = size . y ... You can refer to the API documentation for a complete list of Window 's methods. In case you really need advanced features for your window, you can create one (or even a full GUI) with another library, and embed SFML into it. To do so, you can use the other constructor of Window which takes the OS-specific handle of an existing window. In this case, SFML will create a drawing context inside the given window and catch all its events without interfering with the parent window management. handle = ... # specific to what you're doing and the library you're using SF :: Window . from_handle ( handle ) If you just want an additional, very specific feature, you can also do it the other way round: create an SFML window and get its OS-specific handle to implement things that SFML itself doesn't support. window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) handle = window . system_handle # you can now use the handle with OS specific functions Integrating SFML with other libraries requires some work and won't be described here, but you can refer to the dedicated tutorials, examples or forum posts. Controlling the framerate Sometimes, when your application runs fast, you may notice visual artifacts such as tearing. The reason is that your application's refresh rate is not synchronized with the vertical frequency of the monitor, and as a result, the bottom of the previous frame is mixed with the top of the next one. The solution to this problem is to activate vertical synchronization . It is automatically handled by the graphics card, and can easily be switched on and off with the vertical_sync_enabled= method: window . vertical_sync_enabled = true # call it once, after creating the window After this call, your application will run at the same frequency as the monitor's refresh rate. Sometimes vertical_sync_enabled= will have no effect: this is most likely because vertical synchronization is forced to \"off\" in your graphics driver's settings. It should be set to \"controlled by application\" instead. In other situations, you may also want your application to run at a given framerate, instead of the monitor's frequency. This can be done by calling framerate_limit= : window . framerate_limit = 60 # call it once, after creating the window Unlike vertical_sync_enabled= , this feature is implemented by SFML itself, using a combination of Clock and SF.sleep . An important consequence is that it is not 100% reliable, especially for high framerates: SF.sleep 's resolution depends on the underlying operating system and hardware, and can be as high as 10 or 15 milliseconds. Don't rely on this feature to implement precise timing. Never use both vertical_sync_enabled and framerate_limit at the same time! They would badly mix and make things worse. Things to know about windows Here is a brief list of what you can and cannot do with SFML windows. You can create multiple windows SFML allows you to create multiple windows, and to handle them either all in the main thread, or each one in its own thread (but... see below). In this case, don't forget to have an event loop for each window. Multiple monitors are not correctly supported yet SFML doesn't explicitly manage multiple monitors. As a consequence, you won't be able to choose which monitor a window appears on, and you won't be able to create more than one fullscreen window. This should be improved in a future version. Events must be polled in the window's thread This is an important limitation of most operating systems: the event loop (more precisely, the poll_event or wait_event method) must be called in the same thread that created the window. This means that if you want to create a dedicated thread for event handling, you'll have to make sure that the window is created in this thread too. If you really want to split things between threads, it is more convenient to keep event handling in the main thread and move the rest (rendering, physics, logic, ...) to a separate thread instead. This configuration will also be compatible with the other limitation described below. On OS X, windows and events must be managed in the main thread Yep, that's true. Mac OS X just won't agree if you try to create a window or handle events in a thread other than the main one. On Windows, a window which is bigger than the desktop will not behave correctly For some reason, Windows doesn't like windows that are bigger than the desktop. This includes windows created with VideoMode.get_desktop_mode : with the window decorations (borders and titlebar) added, you end up with a window which is slightly bigger than the desktop.","title":"Opening and managing an SFML window"},{"location":"window/window.html#opening-and-managing-an-sfml-window","text":"Relevant example: simple","title":"Opening and managing an SFML window"},{"location":"window/window.html#introduction","text":"This tutorial only explains how to open and manage a window. Drawing stuff is beyond the scope of the sfml-window module: it is handled by the sfml-graphics module. However, the window management remains exactly the same so reading this tutorial is important in any case.","title":"Introduction"},{"location":"window/window.html#opening-a-window","text":"Windows in CrSFML are defined by the Window class. A window can be created and opened directly upon construction: require \"crsfml\" window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) ... The first argument, the video mode , defines the size of the window (the inner size, without the title bar and borders). Here, we create a window with a size of 800x600 pixels. The VideoMode class has some interesting class methods to get the desktop resolution, or the list of valid video modes for fullscreen mode. Don't hesitate to have a look at its documentation. The second argument is simply the title of the window. This constructor accepts a third optional argument: a style, which allows you to choose which decorations and features you want. You can use any combination of the following styles: SF::Style::None No decoration at all (useful for splash screens, for example); this style cannot be combined with others SF::Style::Titlebar The window has a titlebar SF::Style::Resize The window can be resized and has a maximize button SF::Style::Close The window has a close button SF::Style::Fullscreen The window is shown in fullscreen mode; this style cannot be combined with others, and requires a valid video mode SF::Style::Default The default style, which is a shortcut for Titlebar | Resize | Close There's also a fourth optional argument, which defines OpenGL specific options which are explained in the dedicated OpenGL tutorial .","title":"Opening a window"},{"location":"window/window.html#bringing-the-window-to-life","text":"If you try to execute the code above with nothing in place of the \"...\", you will hardly see anything. First, because the program ends immediately. Second, because there's no event handling -- so even if you added an endless loop to this code, you would see a dead window, unable to be resized or closed. Let's add some code to make this program a bit more interesting: require \"crsfml\" window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) # run the program as long as the window is open while window . open? # check all the window's events that were triggered since the last iteration of the loop while event = window . poll_event # \"close requested\" event: we close the window if event . is_a? SF :: Event :: Closed window . close end end end The above code will open a window, and terminate when the user closes it. Let's see how it works in detail. First, we added a loop that ensures that the application will be refreshed/updated until the window is closed. Most (if not all) CrSFML programs will have this kind of loop, sometimes called the main loop or game loop . Then, the first thing that we want to do inside our game loop is check for any events that occurred. Note that we use a while loop so that all pending events are processed in case there were several. The poll_event method returns an event if there was one pending, or nil otherwise. Whenever we get an event, we must check its type (window closed? key pressed? mouse moved? joystick connected? ...), and react accordingly if we are interested in it. In this case, we only care about the Event::Closed event, which is triggered when the user wants to close the window. At this point, the window is still open and we have to close it explicitly with the close method. This enables you to do something before the window is closed, such as saving the current state of the application, or displaying a message. A mistake that people often make is to forget the event loop, simply because they don't yet care about handling events (they use real-time inputs instead). Without an event loop, the window will become unresponsive. It is important to note that the event loop has two roles: in addition to providing events to the user, it gives the window a chance to process its internal events too, which is required so that it can react to move or resize user actions. After the window has been closed, the main loop exits and the program terminates. At this point, you probably noticed that we haven't talked about drawing something to the window yet. As stated in the introduction, this is not the job of the sfml-window module, and you'll have to jump to the sfml-graphics tutorials if you want to draw things such as sprites, text or shapes. To draw stuff, you can also use OpenGL directly and totally ignore the sfml-graphics module. Window internally creates an OpenGL context and is ready to accept your OpenGL calls. You can learn more about that in the corresponding tutorial . Don't expect to see anything interesting in this window: you may see a uniform color (black or white), or the last contents of the previous application that used OpenGL, or... something else.","title":"Bringing the window to life"},{"location":"window/window.html#playing-with-the-window","text":"Of course, CrSFML allows you to play with your windows a bit. Basic window operations such as changing the size, position, title or icon are supported, but unlike dedicated GUI libraries, SFML doesn't provide advanced features. SFML windows are only meant to provide an environment for OpenGL or SFML drawing. # change the position of the window (relatively to the desktop) window . position = SF . vector2 ( 10 , 50 ) # change the size of the window window . size = SF . vector2 ( 640 , 480 ) # change the title of the window window . title = \"SFML window\" # get the size of the window size = window . size width = size . x height = size . y ... You can refer to the API documentation for a complete list of Window 's methods. In case you really need advanced features for your window, you can create one (or even a full GUI) with another library, and embed SFML into it. To do so, you can use the other constructor of Window which takes the OS-specific handle of an existing window. In this case, SFML will create a drawing context inside the given window and catch all its events without interfering with the parent window management. handle = ... # specific to what you're doing and the library you're using SF :: Window . from_handle ( handle ) If you just want an additional, very specific feature, you can also do it the other way round: create an SFML window and get its OS-specific handle to implement things that SFML itself doesn't support. window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) handle = window . system_handle # you can now use the handle with OS specific functions Integrating SFML with other libraries requires some work and won't be described here, but you can refer to the dedicated tutorials, examples or forum posts.","title":"Playing with the window"},{"location":"window/window.html#controlling-the-framerate","text":"Sometimes, when your application runs fast, you may notice visual artifacts such as tearing. The reason is that your application's refresh rate is not synchronized with the vertical frequency of the monitor, and as a result, the bottom of the previous frame is mixed with the top of the next one. The solution to this problem is to activate vertical synchronization . It is automatically handled by the graphics card, and can easily be switched on and off with the vertical_sync_enabled= method: window . vertical_sync_enabled = true # call it once, after creating the window After this call, your application will run at the same frequency as the monitor's refresh rate. Sometimes vertical_sync_enabled= will have no effect: this is most likely because vertical synchronization is forced to \"off\" in your graphics driver's settings. It should be set to \"controlled by application\" instead. In other situations, you may also want your application to run at a given framerate, instead of the monitor's frequency. This can be done by calling framerate_limit= : window . framerate_limit = 60 # call it once, after creating the window Unlike vertical_sync_enabled= , this feature is implemented by SFML itself, using a combination of Clock and SF.sleep . An important consequence is that it is not 100% reliable, especially for high framerates: SF.sleep 's resolution depends on the underlying operating system and hardware, and can be as high as 10 or 15 milliseconds. Don't rely on this feature to implement precise timing. Never use both vertical_sync_enabled and framerate_limit at the same time! They would badly mix and make things worse.","title":"Controlling the framerate"},{"location":"window/window.html#things-to-know-about-windows","text":"Here is a brief list of what you can and cannot do with SFML windows.","title":"Things to know about windows"},{"location":"window/window.html#you-can-create-multiple-windows","text":"SFML allows you to create multiple windows, and to handle them either all in the main thread, or each one in its own thread (but... see below). In this case, don't forget to have an event loop for each window.","title":"You can create multiple windows"},{"location":"window/window.html#multiple-monitors-are-not-correctly-supported-yet","text":"SFML doesn't explicitly manage multiple monitors. As a consequence, you won't be able to choose which monitor a window appears on, and you won't be able to create more than one fullscreen window. This should be improved in a future version.","title":"Multiple monitors are not correctly supported yet"},{"location":"window/window.html#events-must-be-polled-in-the-windows-thread","text":"This is an important limitation of most operating systems: the event loop (more precisely, the poll_event or wait_event method) must be called in the same thread that created the window. This means that if you want to create a dedicated thread for event handling, you'll have to make sure that the window is created in this thread too. If you really want to split things between threads, it is more convenient to keep event handling in the main thread and move the rest (rendering, physics, logic, ...) to a separate thread instead. This configuration will also be compatible with the other limitation described below.","title":"Events must be polled in the window's thread"},{"location":"window/window.html#on-os-x-windows-and-events-must-be-managed-in-the-main-thread","text":"Yep, that's true. Mac OS X just won't agree if you try to create a window or handle events in a thread other than the main one.","title":"On OS X, windows and events must be managed in the main thread"},{"location":"window/window.html#on-windows-a-window-which-is-bigger-than-the-desktop-will-not-behave-correctly","text":"For some reason, Windows doesn't like windows that are bigger than the desktop. This includes windows created with VideoMode.get_desktop_mode : with the window decorations (borders and titlebar) added, you end up with a window which is slightly bigger than the desktop.","title":"On Windows, a window which is bigger than the desktop will not behave correctly"}]}