<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Designing your own entities with vertex arrays - CrSFML Tutorials</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link href="../style.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Designing your own entities with vertex arrays";
    var mkdocs_page_input_path = "graphics/vertex-array.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> CrSFML Tutorials</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">System module</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../system/time.html">Handling time</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../system/thread.html">Threads</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../system/stream.html">User data streams</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Window module</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../window/window.html">Opening and managing an SFML window</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../window/events.html">Events explained</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../window/inputs.html">Keyboard, mouse and joysticks</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../window/opengl.html">Using OpenGL in an SFML window</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Graphics module</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="draw.html">Drawing 2D stuff</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="sprite.html">Sprites and textures</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="text.html">Text and fonts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="shape.html">Shapes</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="vertex-array.html">Designing your own entities with vertex arrays</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#what-is-a-vertex-and-why-are-they-always-in-arrays">What is a vertex, and why are they always in arrays?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#a-simple-vertex-array">A simple vertex array</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#primitive-types">Primitive types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#texturing">Texturing</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#transforming-a-vertex-array">Transforming a vertex array</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#creating-an-sfml-like-entity">Creating an SFML-like entity</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#example-tile-map">Example: tile map</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#example-particle-system">Example: particle system</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="transform.html">Position, rotation, scale: transforming entities</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="shader.html">Adding special effects with shaders</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="view.html">Controlling the 2D camera with views</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Audio module</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../audio/sounds.html">Playing sounds and music</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../audio/recording.html">Recording audio</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../audio/streams.html">Custom audio streams</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../audio/spatialization.html">Spatialization: Sounds in 3D</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Network module</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../network/socket.html">Communication using sockets</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../network/packet.html">Using packets</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../network/http.html">Web requests with HTTP</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../network/ftp.html">File transfers with FTP</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">CrSFML Tutorials</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Graphics module &raquo;</li>
        
      
    
    <li>Designing your own entities with vertex arrays</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/oprypin/crsfml/blob/tutorials/graphics/vertex-array.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="designing-your-own-entities-with-vertex-arrays">Designing your own entities with vertex arrays</h1>
<h2 id="introduction">Introduction</h2>
<p>SFML provides simple classes for the most common 2D entities. And while more complex entities can easily be created from these building blocks, it isn't always the most efficient solution. For example, you'll reach the limits of your graphics card very quickly if you draw a large number of sprites. The reason is that performance depends in large part on the number of calls to the <code>draw</code> method. Indeed, each call involves setting a set of OpenGL states, resetting matrices, changing textures, etc. All of this is required even when simply drawing two triangles (a sprite). This is far from optimal for your graphics card: Today's GPUs are designed to process large batches of triangles, typically several thousand to millions.</p>
<p>To fill this gap, SFML provides a lower-level mechanism to draw things: Vertex arrays. As a matter of fact, vertex arrays are used internally by all other SFML classes. They allow for a more flexible definition of 2D entities, containing as many triangles as you need. They even allow drawing points or lines.</p>
<h2 id="what-is-a-vertex-and-why-are-they-always-in-arrays">What is a vertex, and why are they always in arrays?</h2>
<p>A vertex is the smallest graphical entity that you can manipulate. In short, it is a graphical point: Naturally, it has a 2D position (x, y), but also a color, and a pair of texture coordinates. We'll go into the roles of these attributes later.</p>
<p>Vertices (plural of vertex) alone don't do much. They are always grouped into <em>primitives</em>: Points (1 vertex), lines (2 vertices), triangles (3 vertices) or quads (4 vertices). You can then combine multiple primitives together to create the final geometry of the entity.</p>
<p>Now you understand why we always talk about vertex arrays, and not vertices alone.</p>
<h2 id="a-simple-vertex-array">A simple vertex array</h2>
<p>Let's have a look at the <a href="http://oprypin.github.io/crsfml/api/SF/Vertex.html">Vertex</a> class now. It's simply a container which contains three public members and no functions besides its constructors. These constructors allow you to construct vertices from the set of attributes you care about -- you don't always need to color or texture your entity.</p>
<pre class="codehilite"><code class="language-crystal"># create a new vertex
vertex = SF::Vertex.new

# set its position
vertex.position = SF.vector2(10, 50)

# set its color
vertex.color = SF::Color::Red

# set its texture coordinates
vertex.tex_coords = SF.vector2f(100, 100)</code></pre>


<p>... or, using the correct constructor:</p>
<pre class="codehilite"><code class="language-crystal">vertex = SF::Vertex.new({10, 50}, SF::Color::Red, {100, 100})</code></pre>


<p>Now, let's define a primitive. Remember, a primitive consists of several vertices, therefore we need a vertex array. CrSFML provides a simple wrapper for this: <a href="http://oprypin.github.io/crsfml/api/SF/VertexArray.html">VertexArray</a>. It provides the semantics of an array, and also stores the type of primitive its vertices define.</p>
<pre class="codehilite"><code class="language-crystal"># create an array of 3 vertices that define a triangle primitive
triangle = SF::VertexArray.new(SF::Triangles, 3)

# define the positions and colors of the triangle's points
triangle[0] = SF::Vertex.new(SF.vector2(10, 10), SF::Color::Red)
triangle[1] = SF::Vertex.new(SF.vector2(100, 10), SF::Color::Blue)
triangle[2] = SF::Vertex.new(SF.vector2(100, 100), SF::Color::Green)

# no texture coordinates here, we'll see that later</code></pre>


<p>Your triangle is ready and you can now draw it. Drawing a vertex array can be done similar to drawing any other CrSFML entity, by using the <code>draw</code> function:</p>
<pre class="codehilite"><code class="language-crystal">window.draw(triangle)</code></pre>


<p><img alt="A triangle made with vertices" src="images/vertex-array-triangle.png" /></p>
<p>You can see that the vertices' color is interpolated to fill the primitive. This is a nice way of creating gradients.</p>
<p>Note that you don't have to use the <a href="http://oprypin.github.io/crsfml/api/SF/VertexArray.html">VertexArray</a> class. It's just defined for convenience, it's nothing more than an array along with a <code>SF::PrimitiveType</code>. If you need more flexibility, or a normal (or static) array, you can use your own storage. You must then use the overload of the <code>draw</code> function which takes an array of vertices and the primitive type.</p>
<pre class="codehilite"><code class="language-crystal">vertices = [
  SF::Vertex.new(...),
  SF::Vertex.new(...)
]

window.draw(vertices, SF::Lines)</code></pre>


<h2 id="primitive-types">Primitive types</h2>
<p>Let's pause for a while and see what kind of primitives you can create. As explained above, you can define the most basic 2D primitives: Point, line, triangle and quad (quad exists merely as a convenience, internally the graphics card breaks it into two triangles). There are also "chained" variants of these primitive types which allow for sharing of vertices among two consecutive primitives. This can be useful because consecutive primitives are often connected in some way.</p>
<p>Let's have a look at the full list:</p>
<table>
<thead>
<tr>
<th>Primitive type</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SF::Points</code></td>
<td>A set of unconnected points. These points have no thickness: They will always occupy a single pixel, regardless of the current transform and view.</td>
<td><img alt="The SF::Points primitive type" src="images/vertex-array-points.png" /></td>
</tr>
<tr>
<td><code>SF::Lines</code></td>
<td>A set of unconnected lines. These lines have no thickness: They will always be one pixel wide, regardless of the current transform and view.</td>
<td><img alt="The SF::Lines primitive type" src="images/vertex-array-lines.png" /></td>
</tr>
<tr>
<td><code>SF::LinesStrip</code></td>
<td>A set of connected lines. The end vertex of one line is used as the start vertex of the next one.</td>
<td><img alt="The SF::LinesStrip primitive type" src="images/vertex-array-lines-strip.png" /></td>
</tr>
<tr>
<td><code>SF::Triangles</code></td>
<td>A set of unconnected triangles.</td>
<td><img alt="The SF::Triangles primitive type" src="images/vertex-array-triangles.png" /></td>
</tr>
<tr>
<td><code>SF::TrianglesStrip</code></td>
<td>A set of connected triangles. Each triangle shares its two last vertices with the next one.</td>
<td><img alt="The SF::TrianglesStrip primitive type" src="images/vertex-array-triangles-strip.png" /></td>
</tr>
<tr>
<td><code>SF::TrianglesFan</code></td>
<td>A set of triangles connected to a central point. The first vertex is the center, then each new vertex defines a new triangle, using the center and the previous vertex.</td>
<td><img alt="The SF::TrianglesFan primitive type" src="images/vertex-array-triangles-fan.png" /></td>
</tr>
<tr>
<td><code>SF::Quads</code></td>
<td>A set of unconnected quads. The 4 points of each quad must be defined consistently, either in clockwise or counter-clockwise order.</td>
<td><img alt="The SF::Quads primitive type" src="images/vertex-array-quads.png" /></td>
</tr>
</tbody>
</table>
<h2 id="texturing">Texturing</h2>
<p>Like other SFML entities, vertex arrays can also be textured. To do so, you'll need to manipulate the <code>tex_coords</code> attribute of the vertices. This attribute defines which pixel of the texture is mapped to the vertex.</p>
<pre class="codehilite"><code class="language-crystal"># create a quad
quad = SF::VertexArray.new(SF::Quads, 4)

# define it as a rectangle, located at (10, 10) and with size 100x100
# define its texture area to be a 25x50 rectangle starting at (0, 0)
quad.append SF::Vertex.new({ 10,  10}, tex_coords: { 0,  0})
quad.append SF::Vertex.new({110,  10}, tex_coords: {25,  0})
quad.append SF::Vertex.new({110, 110}, tex_coords: {25, 50})
quad.append SF::Vertex.new({ 10, 110}, tex_coords: { 0, 50})</code></pre>


<p>Texture coordinates are defined in <em>pixels</em> (just like the <code>texture_rect</code> of sprites and shapes). They are <em>not</em> normalized (between 0 and 1), as people who are used to OpenGL programming might expect.</p>
<p>Vertex arrays are low-level entities, they only deal with geometry and do not store additional attributes like a texture. To draw a vertex array with a texture, you must pass it directly to the <code>draw</code> method, through a <a href="http://oprypin.github.io/crsfml/api/SF/RenderStates.html">RenderStates</a> object:</p>
<pre class="codehilite"><code class="language-crystal">vertices = ... # SF::VertexArray
texture = ... # SF::Texture

...

states = SF::RenderStates.new
states.texture = texture

window.draw(vertices, states)</code></pre>


<h2 id="transforming-a-vertex-array">Transforming a vertex array</h2>
<p>Transforming is similar to texturing. The transform is not stored in the vertex array, you must pass it to the <code>draw</code> method.</p>
<pre class="codehilite"><code class="language-crystal">vertices = ... # SF::VertexArray
transform = ... # SF::Transform

...

states = SF::RenderStates.new
states.transform = transform

window.draw(vertices, states)</code></pre>


<p>To know more about transformations and the <a href="http://oprypin.github.io/crsfml/api/SF/Transform.html">Transform</a> class, you can read the tutorial on <a href="transform.html" title="Transforming entities tutorial">transforming entities</a>.</p>
<h2 id="creating-an-sfml-like-entity">Creating an SFML-like entity</h2>
<p>Now that you know how to define your own textured/colored/transformed entity, wouldn't it be nice to wrap it in an SFML-style class? Fortunately, SFML makes this easy for you by providing the <a href="http://oprypin.github.io/crsfml/api/SF/Drawable.html">Drawable</a> module and <a href="http://oprypin.github.io/crsfml/api/SF/Transformable.html">Transformable</a> base class. These two classes are the base of the built-in SFML entities Sprite, Text and Shape.</p>
<p><a href="http://oprypin.github.io/crsfml/api/SF/Drawable.html">Drawable</a> is an interface: it declares a single abstract method. Including sf::Drawable allows you to draw instances of your class the same way as SFML classes:</p>
<pre class="codehilite"><code class="language-crystal">class MyEntity
  include SF::Drawable

  def draw(target : SF::RenderTarget, states : SF::RenderStates)
  end
end

entity = MyEntity.new
window.draw(entity) # internally calls entity.draw</code></pre>


<p>Subclassing the <a href="http://oprypin.github.io/crsfml/api/SF/Transformable.html">Transformable</a> class automatically adds the same transformation methods to your class as other CrSFML classes (<code>position=</code>, <code>rotation=</code>, <code>move</code>, <code>scale</code>, ...). You can learn more about this in the tutorial on <a href="transform.html" title="Transforming entities tutorial">transforming entities</a>.</p>
<p>Using these two features and a vertex array (in this example we'll also add a texture), here is what a typical CrSFML-like graphical class would look like:</p>
<pre class="codehilite"><code class="language-crystal">class MyEntity &lt; SF::Transformable
  include SF::Drawable

  # add methods to play with the entity's geometry / colors / texturing...

  def draw(target, states)
    # apply the entity's transform -- combine it with the one that was passed by the caller
    states.transform *= transform # transform() is defined by SF::Transformable

    # apply the texture
    states.texture = @texture

    # you may also override states.shader or states.blend_mode if you want

    # draw the vertex array
    target.draw(@vertices, states)
  end
end</code></pre>


<p>You can then use this class as if it were a built-in CrSFML class:</p>
<pre class="codehilite"><code class="language-crystal">entity = MyEntity.new

# you can transform it
entity.position = SF.vector2(10, 50)
entity.rotation = 45

# you can draw it
window.draw(entity)</code></pre>


<h2 id="example-tile-map">Example: tile map</h2>
<p>Relevant example: <strong><a href="https://github.com/oprypin/crsfml-examples/tree/master/minesweeper">minesweeper</a></strong></p>
<p>With what we've seen above, let's create a class that encapsulates a tile map. The whole map will be contained in a single vertex array, therefore it will be super fast to draw. Note that we can apply this strategy only if the whole tile set can fit into a single texture. Otherwise, we would have to use at least one vertex array per texture.</p>
<p><img alt="The tileset" src="images/vertex-array-tileset.png" width="512" height="128" style="image-rendering: -moz-crisp-edges; image-rendering: pixelated"></p>
<pre class="codehilite"><code class="language-crystal">class TileMap &lt; SF::Transformable
  include SF::Drawable

  def initialize(tileset, tile_size, tiles, width, height)
    super()

    # load the tileset texture
    @tileset = SF::Texture.from_file(tileset)

    @vertices = SF::VertexArray.new(SF::Quads)

    tiles_per_row = @tileset.size.x / tile_size.x

    # populate the vertex array, with one quad per tile
    (0...height).each do |y|
      (0...width).each do |x|
        # get the current tile number
        tile_index = tiles[width*y + x]

        # find its position in the tileset texture
        tile_pos = SF.vector2(
          tile_index % tiles_per_row,
          tile_index / tiles_per_row
        )

        destination = SF.vector2(x, y)

        # define its 4 corners and texture coordinates
        { {0, 0}, {1, 0}, {1, 1}, {0, 1} }.each do |delta|
          @vertices.append SF::Vertex.new(
            (destination + delta) * tile_size,
            tex_coords: (tile_pos + delta) * tile_size
          )
        end
      end
    end
  end

  def draw(target, states)
    # apply the transform
    states.transform *= transform()

    # apply the tileset texture
    states.texture = @tileset

    # draw the vertex array
    target.draw(@vertices, states)
  end
end</code></pre>


<p>And now, the application that uses it:</p>
<pre class="codehilite"><code class="language-crystal"># create the window
window = SF::RenderWindow.new(SF::VideoMode.new(512, 256), &quot;Tilemap&quot;)

# define the level with an array of tile indices
level = [
  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3,
  0, 1, 0, 0, 2, 0, 3, 3, 3, 0, 1, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 3, 3, 3, 0, 0, 0, 1, 1, 1, 2, 0, 0,
  0, 0, 1, 0, 3, 0, 2, 2, 0, 0, 1, 1, 1, 1, 2, 0,
  2, 0, 1, 0, 3, 0, 2, 2, 2, 0, 1, 1, 1, 1, 1, 1,
  0, 0, 1, 0, 3, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1
]

# create the tilemap from the level definition
map = TileMap.new(&quot;tileset.png&quot;, SF.vector2(32, 32), level, 16, 8)

# run the main loop
while window.open?
  # handle events
  while event = window.poll_event
    if event.is_a? SF::Event::Closed
      window.close
    end
  end

  # draw the map
  window.clear
  window.draw(map)
  window.display
end</code></pre>


<p><img alt="The tilemap example" src="images/vertex-array-tilemap.png" /></p>
<h2 id="example-particle-system">Example: particle system</h2>
<p>This second example implements another common entity: The particle system. This one is very simple, with no texture and as few parameters as possible. It demonstrates the use of the <code>SF::Points</code> primitive type with a dynamic vertex array which changes every frame.</p>
<pre class="codehilite"><code class="language-crystal">struct Particle
  def initialize(@velocity, @lifetime, @position)
    @total_lifetime = @lifetime
  end
  property velocity : SF::Vector2f
  property lifetime : SF::Time
  property position : SF::Vector2f
  getter total_lifetime : SF::Time
end

class ParticleSystem &lt; SF::Transformable
  include SF::Drawable

  def initialize(@count : Int32)
    super()

    @particles = [] of Particle
    @emitter = SF::Vector2f.new(0.0f32, 0.0f32)
    @random = Random.new
  end

  property emitter

  def update(elapsed)
    @particles.map! do |p|
      # update the position of the particle
      p.position += p.velocity * elapsed.as_seconds

      # update the particle lifetime
      p.lifetime -= elapsed

      # if the particle is dead, remove it
      if p.lifetime &lt;= SF::Time::Zero
        new_particle
      else
        p
      end
    end

    if @particles.size &lt; @count
      @particles &lt;&lt; new_particle
    end
  end

  def draw(target, states)
    vertices = @particles.map do |p|
      # set the alpha (transparency) of the particle according to its lifetime
      ratio = p.lifetime / p.total_lifetime
      color = SF.color(255, 255, 255, (ratio * 255).to_u8)

      SF::Vertex.new(p.position, color)
    end

    # apply the transform
    states.transform *= transform()

    # draw the vertex array
    target.draw(vertices, SF::Points, states)
  end

  private def new_particle
    # give a random velocity and lifetime to the particle
    angle = @random.rand(Math::PI * 2)
    speed = @random.rand(50.0..100.0)
    velocity = SF.vector2f(Math.cos(angle) * speed, Math.sin(angle) * speed)
    lifetime = SF.seconds(@random.rand(1.0..3.0))

    Particle.new(velocity, lifetime, @emitter)
  end
end</code></pre>


<p>And a little demo that uses it:</p>
<pre class="codehilite"><code class="language-crystal"># create the window
window = SF::RenderWindow.new(SF::VideoMode.new(800, 600), &quot;Particles&quot;)

# create the particle system
particles = ParticleSystem.new(1000)

# create a clock to track the elapsed time
clock = SF::Clock.new

# run the main loop
while window.open?

  # handle events
  while event = window.poll_event
    if event.is_a? SF::Event::Closed
      window.close
    end
  end

  # make the particle system emitter follow the mouse
  mouse = SF::Mouse.get_position(window)
  particles.emitter = window.map_pixel_to_coords(mouse)

  # update it
  elapsed = clock.restart
  particles.update(elapsed)

  # draw it
  window.clear
  window.draw(particles)
  window.display
end</code></pre>


<p><img alt="The particles example" src="images/vertex-array-particles.png" /></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="transform.html" class="btn btn-neutral float-right" title="Position, rotation, scale: transforming entities">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="shape.html" class="btn btn-neutral" title="Shapes"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/oprypin/crsfml/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="shape.html" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="transform.html" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
